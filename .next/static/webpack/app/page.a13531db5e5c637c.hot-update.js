"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/webrtc.ts":
/*!***************************!*\
  !*** ./src/lib/webrtc.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   webRTCService: function() { return /* binding */ webRTCService; }\n/* harmony export */ });\n/* harmony import */ var _socket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./socket */ \"(app-pages-browser)/./src/lib/socket.ts\");\n/* __next_internal_client_entry_do_not_use__ webRTCService,default auto */ \n// ICE servers configuration for STUN/TURN\nconst ICE_SERVERS = {\n    iceServers: [\n        {\n            urls: \"stun:stun.l.google.com:19302\"\n        },\n        {\n            urls: \"stun:stun1.l.google.com:19302\"\n        },\n        {\n            urls: \"stun:stun2.l.google.com:19302\"\n        },\n        {\n            urls: \"stun:stun3.l.google.com:19302\"\n        },\n        {\n            urls: \"stun:stun4.l.google.com:19302\"\n        }\n    ],\n    iceCandidatePoolSize: 10\n};\n// Check if WebRTC is supported and we're in a secure context\nfunction checkWebRTCSupport() {\n    // Check if we're in a browser environment\n    if (false) {}\n    // Check for secure context (HTTPS or localhost)\n    if (!window.isSecureContext) {\n        const isLocalhost = window.location.hostname === \"localhost\" || window.location.hostname === \"127.0.0.1\";\n        if (!isLocalhost) {\n            return {\n                supported: false,\n                error: \"WebRTC requires HTTPS. Please access via localhost:3004 or use HTTPS.\"\n            };\n        }\n    }\n    // Check for mediaDevices API\n    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n        return {\n            supported: false,\n            error: \"Your browser does not support WebRTC. Please use a modern browser like Chrome, Firefox, or Edge.\"\n        };\n    }\n    // Check for RTCPeerConnection\n    if (!window.RTCPeerConnection) {\n        return {\n            supported: false,\n            error: \"WebRTC is not fully supported in your browser.\"\n        };\n    }\n    return {\n        supported: true\n    };\n}\nclass WebRTCService {\n    setCallbacks(callbacks) {\n        this.callbacks = callbacks;\n    }\n    async initializeMedia(type) {\n        // Check WebRTC support first\n        const support = checkWebRTCSupport();\n        if (!support.supported) {\n            var _this_callbacks_onError, _this_callbacks;\n            const error = new Error(support.error || \"WebRTC not supported\");\n            console.error(\"❌ WebRTC not supported:\", support.error);\n            (_this_callbacks_onError = (_this_callbacks = this.callbacks).onError) === null || _this_callbacks_onError === void 0 ? void 0 : _this_callbacks_onError.call(_this_callbacks, error);\n            throw error;\n        }\n        try {\n            var _this_callbacks_onLocalStream, _this_callbacks1;\n            // Stop any existing streams first\n            this.stopLocalStream();\n            const constraints = {\n                audio: {\n                    echoCancellation: true,\n                    noiseSuppression: true,\n                    autoGainControl: true\n                },\n                video: type === \"video\" ? {\n                    width: {\n                        ideal: 1280,\n                        max: 1920\n                    },\n                    height: {\n                        ideal: 720,\n                        max: 1080\n                    },\n                    frameRate: {\n                        ideal: 30,\n                        max: 60\n                    },\n                    facingMode: \"user\"\n                } : false\n            };\n            console.log(\"\\uD83D\\uDCF9 Requesting media with constraints:\", constraints);\n            this.localStream = await navigator.mediaDevices.getUserMedia(constraints);\n            console.log(\"✅ Got local stream:\", this.localStream.getTracks().map((t)=>\"\".concat(t.kind, \": \").concat(t.label)));\n            this.callType = type;\n            (_this_callbacks_onLocalStream = (_this_callbacks1 = this.callbacks).onLocalStream) === null || _this_callbacks_onLocalStream === void 0 ? void 0 : _this_callbacks_onLocalStream.call(_this_callbacks1, this.localStream);\n            return this.localStream;\n        } catch (error) {\n            var _this_callbacks_onError1, _this_callbacks2;\n            console.error(\"❌ Error accessing media devices:\", error);\n            // Provide user-friendly error messages\n            let errorMessage = \"Failed to access camera/microphone\";\n            if (error.name === \"NotAllowedError\" || error.name === \"PermissionDeniedError\") {\n                errorMessage = \"Camera/microphone permission denied. Please allow access in your browser settings.\";\n            } else if (error.name === \"NotFoundError\" || error.name === \"DevicesNotFoundError\") {\n                errorMessage = \"No camera or microphone found. Please connect a device and try again.\";\n            } else if (error.name === \"NotReadableError\" || error.name === \"TrackStartError\") {\n                errorMessage = \"Camera/microphone is already in use by another application.\";\n            } else if (error.name === \"OverconstrainedError\") {\n                errorMessage = \"Camera does not support the requested video quality.\";\n            } else if (error.name === \"TypeError\") {\n                errorMessage = \"WebRTC requires HTTPS. Please access via localhost:3004\";\n            }\n            const customError = new Error(errorMessage);\n            (_this_callbacks_onError1 = (_this_callbacks2 = this.callbacks).onError) === null || _this_callbacks_onError1 === void 0 ? void 0 : _this_callbacks_onError1.call(_this_callbacks2, customError);\n            throw customError;\n        }\n    }\n    async createPeerConnection() {\n        if (this.peerConnection) {\n            console.log(\"♻️ Closing existing peer connection\");\n            this.peerConnection.close();\n        }\n        console.log(\"\\uD83D\\uDD17 Creating new RTCPeerConnection\");\n        this.peerConnection = new RTCPeerConnection(ICE_SERVERS);\n        // Add local tracks to peer connection\n        if (this.localStream) {\n            this.localStream.getTracks().forEach((track)=>{\n                console.log(\"➕ Adding \".concat(track.kind, \" track to peer connection\"));\n                this.peerConnection.addTrack(track, this.localStream);\n            });\n        }\n        // Handle incoming tracks\n        this.peerConnection.ontrack = (event)=>{\n            var _this_callbacks_onRemoteStream, _this_callbacks;\n            console.log(\"\\uD83D\\uDCE5 Received remote track:\", event.track.kind);\n            if (!this.remoteStream) {\n                this.remoteStream = new MediaStream();\n            }\n            event.streams[0].getTracks().forEach((track)=>{\n                console.log(\"➕ Adding remote \".concat(track.kind, \" track\"));\n                this.remoteStream.addTrack(track);\n            });\n            (_this_callbacks_onRemoteStream = (_this_callbacks = this.callbacks).onRemoteStream) === null || _this_callbacks_onRemoteStream === void 0 ? void 0 : _this_callbacks_onRemoteStream.call(_this_callbacks, this.remoteStream, this.remoteUserId);\n        };\n        // Handle ICE candidates\n        this.peerConnection.onicecandidate = (event)=>{\n            if (event.candidate) {\n                console.log(\"\\uD83E\\uDDCA Sending ICE candidate\");\n                _socket__WEBPACK_IMPORTED_MODULE_0__.socketService.sendIceCandidate({\n                    candidate: event.candidate.toJSON(),\n                    to: this.remoteUserId\n                });\n            }\n        };\n        // Handle connection state changes\n        this.peerConnection.onconnectionstatechange = ()=>{\n            var _this_peerConnection, _this_callbacks_onConnectionStateChange, _this_callbacks;\n            const state = (_this_peerConnection = this.peerConnection) === null || _this_peerConnection === void 0 ? void 0 : _this_peerConnection.connectionState;\n            console.log(\"\\uD83D\\uDD04 Connection state:\", state);\n            (_this_callbacks_onConnectionStateChange = (_this_callbacks = this.callbacks).onConnectionStateChange) === null || _this_callbacks_onConnectionStateChange === void 0 ? void 0 : _this_callbacks_onConnectionStateChange.call(_this_callbacks, state);\n            if (state === \"failed\" || state === \"disconnected\" || state === \"closed\") {\n                console.log(\"\\uD83D\\uDCF4 Connection ended with state:\", state);\n            }\n        };\n        // Handle ICE connection state changes\n        this.peerConnection.oniceconnectionstatechange = ()=>{\n            var _this_peerConnection, _this_callbacks_onIceConnectionStateChange, _this_callbacks;\n            const state = (_this_peerConnection = this.peerConnection) === null || _this_peerConnection === void 0 ? void 0 : _this_peerConnection.iceConnectionState;\n            console.log(\"\\uD83E\\uDDCA ICE connection state:\", state);\n            (_this_callbacks_onIceConnectionStateChange = (_this_callbacks = this.callbacks).onIceConnectionStateChange) === null || _this_callbacks_onIceConnectionStateChange === void 0 ? void 0 : _this_callbacks_onIceConnectionStateChange.call(_this_callbacks, state);\n        };\n        // Handle ICE gathering state changes\n        this.peerConnection.onicegatheringstatechange = ()=>{\n            var _this_peerConnection;\n            console.log(\"\\uD83E\\uDDCA ICE gathering state:\", (_this_peerConnection = this.peerConnection) === null || _this_peerConnection === void 0 ? void 0 : _this_peerConnection.iceGatheringState);\n        };\n        // Process any pending ICE candidates\n        if (this.pendingIceCandidates.length > 0) {\n            console.log(\"\\uD83D\\uDCE6 Processing \".concat(this.pendingIceCandidates.length, \" pending ICE candidates\"));\n            for (const candidate of this.pendingIceCandidates){\n                await this.addIceCandidate(candidate);\n            }\n            this.pendingIceCandidates = [];\n        }\n        return this.peerConnection;\n    }\n    async initiateCall(remoteUserId, callId, type) {\n        console.log(\"\\uD83D\\uDCDE Initiating \".concat(type, \" call to \").concat(remoteUserId));\n        this.isInitiator = true;\n        this.remoteUserId = remoteUserId;\n        this.callId = callId;\n        this.callType = type;\n        try {\n            // Initialize media first\n            await this.initializeMedia(type);\n            // Create peer connection\n            await this.createPeerConnection();\n            // Create and send offer\n            const offer = await this.peerConnection.createOffer({\n                offerToReceiveAudio: true,\n                offerToReceiveVideo: type === \"video\"\n            });\n            console.log(\"\\uD83D\\uDCE4 Created offer:\", offer.type);\n            await this.peerConnection.setLocalDescription(offer);\n            // Send call signal to remote user\n            _socket__WEBPACK_IMPORTED_MODULE_0__.socketService.callUser({\n                userToCall: remoteUserId,\n                signalData: offer,\n                callType: type,\n                callId: callId\n            });\n            console.log(\"\\uD83D\\uDCE4 Sent call signal to:\", remoteUserId);\n        } catch (error) {\n            var _this_callbacks_onError, _this_callbacks;\n            console.error(\"❌ Error initiating call:\", error);\n            (_this_callbacks_onError = (_this_callbacks = this.callbacks).onError) === null || _this_callbacks_onError === void 0 ? void 0 : _this_callbacks_onError.call(_this_callbacks, error);\n            throw error;\n        }\n    }\n    async acceptCall(remoteUserId, callId, type, offer) {\n        console.log(\"\\uD83D\\uDCDE Accepting \".concat(type, \" call from \").concat(remoteUserId));\n        this.isInitiator = false;\n        this.remoteUserId = remoteUserId;\n        this.callId = callId;\n        this.callType = type;\n        try {\n            // Initialize media first\n            await this.initializeMedia(type);\n            // Create peer connection\n            await this.createPeerConnection();\n            // Set remote description (the offer)\n            console.log(\"\\uD83D\\uDCE5 Setting remote description (offer)\");\n            await this.peerConnection.setRemoteDescription(new RTCSessionDescription(offer));\n            // Create and send answer\n            const answer = await this.peerConnection.createAnswer();\n            console.log(\"\\uD83D\\uDCE4 Created answer:\", answer.type);\n            await this.peerConnection.setLocalDescription(answer);\n            // Send answer back to caller\n            _socket__WEBPACK_IMPORTED_MODULE_0__.socketService.answerCall({\n                signal: answer,\n                to: remoteUserId,\n                callId: callId\n            });\n            console.log(\"\\uD83D\\uDCE4 Sent answer to:\", remoteUserId);\n        } catch (error) {\n            var _this_callbacks_onError, _this_callbacks;\n            console.error(\"❌ Error accepting call:\", error);\n            (_this_callbacks_onError = (_this_callbacks = this.callbacks).onError) === null || _this_callbacks_onError === void 0 ? void 0 : _this_callbacks_onError.call(_this_callbacks, error);\n            throw error;\n        }\n    }\n    async handleAnswer(answer) {\n        console.log(\"\\uD83D\\uDCE5 Handling answer\");\n        if (!this.peerConnection) {\n            console.error(\"❌ No peer connection exists\");\n            return;\n        }\n        try {\n            await this.peerConnection.setRemoteDescription(new RTCSessionDescription(answer));\n            console.log(\"✅ Set remote description (answer)\");\n        } catch (error) {\n            var _this_callbacks_onError, _this_callbacks;\n            console.error(\"❌ Error handling answer:\", error);\n            (_this_callbacks_onError = (_this_callbacks = this.callbacks).onError) === null || _this_callbacks_onError === void 0 ? void 0 : _this_callbacks_onError.call(_this_callbacks, error);\n        }\n    }\n    async addIceCandidate(candidate) {\n        if (!this.peerConnection || !this.peerConnection.remoteDescription) {\n            console.log(\"\\uD83D\\uDCE6 Queuing ICE candidate (no remote description yet)\");\n            this.pendingIceCandidates.push(candidate);\n            return;\n        }\n        try {\n            await this.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\n            console.log(\"✅ Added ICE candidate\");\n        } catch (error) {\n            console.error(\"❌ Error adding ICE candidate:\", error);\n        }\n    }\n    async startScreenShare() {\n        // Check WebRTC support first\n        const support = checkWebRTCSupport();\n        if (!support.supported) {\n            var _this_callbacks_onError, _this_callbacks;\n            console.error(\"❌ Screen share not supported:\", support.error);\n            (_this_callbacks_onError = (_this_callbacks = this.callbacks).onError) === null || _this_callbacks_onError === void 0 ? void 0 : _this_callbacks_onError.call(_this_callbacks, new Error(support.error || \"Screen share not supported\"));\n            return null;\n        }\n        try {\n            console.log(\"\\uD83D\\uDDA5️ Starting screen share\");\n            this.screenStream = await navigator.mediaDevices.getDisplayMedia({\n                video: {\n                    cursor: \"always\"\n                },\n                audio: false\n            });\n            const videoTrack = this.screenStream.getVideoTracks()[0];\n            // Store original video track\n            if (this.localStream) {\n                this.originalVideoTrack = this.localStream.getVideoTracks()[0] || null;\n            }\n            // Handle when user stops sharing via browser UI\n            videoTrack.onended = ()=>{\n                console.log(\"\\uD83D\\uDDA5️ Screen share ended by user\");\n                this.stopScreenShare();\n            };\n            // Replace video track in peer connection\n            if (this.peerConnection && this.localStream) {\n                const sender = this.peerConnection.getSenders().find((s)=>{\n                    var _s_track;\n                    return ((_s_track = s.track) === null || _s_track === void 0 ? void 0 : _s_track.kind) === \"video\";\n                });\n                if (sender) {\n                    await sender.replaceTrack(videoTrack);\n                    console.log(\"✅ Replaced video track with screen share\");\n                }\n            }\n            this.isScreenSharing = true;\n            return this.screenStream;\n        } catch (error) {\n            var _this_callbacks_onError1, _this_callbacks1;\n            console.error(\"❌ Error starting screen share:\", error);\n            (_this_callbacks_onError1 = (_this_callbacks1 = this.callbacks).onError) === null || _this_callbacks_onError1 === void 0 ? void 0 : _this_callbacks_onError1.call(_this_callbacks1, error);\n            return null;\n        }\n    }\n    async stopScreenShare() {\n        console.log(\"\\uD83D\\uDDA5️ Stopping screen share\");\n        try {\n            // Stop screen stream tracks\n            if (this.screenStream) {\n                this.screenStream.getTracks().forEach((track)=>track.stop());\n                this.screenStream = null;\n            }\n            // Restore original video track\n            if (this.peerConnection && this.originalVideoTrack) {\n                const sender = this.peerConnection.getSenders().find((s)=>{\n                    var _s_track;\n                    return ((_s_track = s.track) === null || _s_track === void 0 ? void 0 : _s_track.kind) === \"video\";\n                });\n                if (sender) {\n                    await sender.replaceTrack(this.originalVideoTrack);\n                    console.log(\"✅ Restored original video track\");\n                }\n            } else if (this.peerConnection && this.callType === \"video\") {\n                // Re-acquire camera if original track is gone\n                try {\n                    const newStream = await navigator.mediaDevices.getUserMedia({\n                        video: true\n                    });\n                    const newVideoTrack = newStream.getVideoTracks()[0];\n                    const sender = this.peerConnection.getSenders().find((s)=>{\n                        var _s_track;\n                        return ((_s_track = s.track) === null || _s_track === void 0 ? void 0 : _s_track.kind) === \"video\";\n                    });\n                    if (sender) {\n                        await sender.replaceTrack(newVideoTrack);\n                        console.log(\"✅ Acquired new video track\");\n                    }\n                    // Update local stream\n                    if (this.localStream) {\n                        var _this_callbacks_onLocalStream, _this_callbacks;\n                        const oldVideoTrack = this.localStream.getVideoTracks()[0];\n                        if (oldVideoTrack) {\n                            this.localStream.removeTrack(oldVideoTrack);\n                        }\n                        this.localStream.addTrack(newVideoTrack);\n                        (_this_callbacks_onLocalStream = (_this_callbacks = this.callbacks).onLocalStream) === null || _this_callbacks_onLocalStream === void 0 ? void 0 : _this_callbacks_onLocalStream.call(_this_callbacks, this.localStream);\n                    }\n                } catch (error) {\n                    console.error(\"❌ Error re-acquiring camera:\", error);\n                }\n            }\n            this.isScreenSharing = false;\n            this.originalVideoTrack = null;\n        } catch (error) {\n            console.error(\"❌ Error stopping screen share:\", error);\n        }\n    }\n    toggleMute() {\n        if (this.localStream) {\n            const audioTrack = this.localStream.getAudioTracks()[0];\n            if (audioTrack) {\n                audioTrack.enabled = !audioTrack.enabled;\n                console.log(\"\\uD83C\\uDFA4 Mic \".concat(audioTrack.enabled ? \"unmuted\" : \"muted\"));\n                return !audioTrack.enabled; // Return isMuted state\n            }\n        }\n        return false;\n    }\n    toggleVideo() {\n        if (this.localStream && !this.isScreenSharing) {\n            const videoTrack = this.localStream.getVideoTracks()[0];\n            if (videoTrack) {\n                videoTrack.enabled = !videoTrack.enabled;\n                console.log(\"\\uD83D\\uDCF9 Video \".concat(videoTrack.enabled ? \"enabled\" : \"disabled\"));\n                return videoTrack.enabled;\n            }\n        }\n        return true;\n    }\n    getIsScreenSharing() {\n        return this.isScreenSharing;\n    }\n    stopLocalStream() {\n        if (this.localStream) {\n            this.localStream.getTracks().forEach((track)=>{\n                track.stop();\n                console.log(\"⏹️ Stopped \".concat(track.kind, \" track\"));\n            });\n            this.localStream = null;\n        }\n    }\n    endCall() {\n        var _this_callbacks_onCallEnded, _this_callbacks;\n        console.log(\"\\uD83D\\uDCF4 Ending call\");\n        // Stop screen share if active\n        if (this.isScreenSharing) {\n            this.stopScreenShare();\n        }\n        // Stop local stream\n        this.stopLocalStream();\n        // Stop remote stream\n        if (this.remoteStream) {\n            this.remoteStream.getTracks().forEach((track)=>track.stop());\n            this.remoteStream = null;\n        }\n        // Close peer connection\n        if (this.peerConnection) {\n            this.peerConnection.close();\n            this.peerConnection = null;\n        }\n        // Reset state\n        this.pendingIceCandidates = [];\n        this.isInitiator = false;\n        this.remoteUserId = \"\";\n        this.callId = \"\";\n        this.originalVideoTrack = null;\n        this.isScreenSharing = false;\n        (_this_callbacks_onCallEnded = (_this_callbacks = this.callbacks).onCallEnded) === null || _this_callbacks_onCallEnded === void 0 ? void 0 : _this_callbacks_onCallEnded.call(_this_callbacks);\n    }\n    getLocalStream() {\n        return this.localStream;\n    }\n    getRemoteStream() {\n        return this.remoteStream;\n    }\n    getPeerConnection() {\n        return this.peerConnection;\n    }\n    getCallId() {\n        return this.callId;\n    }\n    getRemoteUserId() {\n        return this.remoteUserId;\n    }\n    constructor(){\n        this.peerConnection = null;\n        this.localStream = null;\n        this.remoteStream = null;\n        this.screenStream = null;\n        this.callbacks = {};\n        this.pendingIceCandidates = [];\n        this.isInitiator = false;\n        this.remoteUserId = \"\";\n        this.callId = \"\";\n        this.callType = \"audio\";\n        this.isScreenSharing = false;\n        this.originalVideoTrack = null;\n    }\n}\n// Export singleton instance\nconst webRTCService = new WebRTCService();\n/* harmony default export */ __webpack_exports__[\"default\"] = (webRTCService);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LElBQUksQ0FBQ3pFLFlBQVk7SUFDMUI7SUFFQTBFLG9CQUE4QztRQUM1QyxPQUFPLElBQUksQ0FBQ2pGLGNBQWM7SUFDNUI7SUFFQWtGLFlBQW9CO1FBQ2xCLE9BQU8sSUFBSSxDQUFDcEQsTUFBTTtJQUNwQjtJQUVBcUQsa0JBQTBCO1FBQ3hCLE9BQU8sSUFBSSxDQUFDeEUsWUFBWTtJQUMxQjs7YUE5Y1FYLGlCQUEyQzthQUMzQ1osY0FBa0M7YUFDbENtQixlQUFtQzthQUNuQzZDLGVBQW1DO2FBQ25DckYsWUFBc0MsQ0FBQzthQUN2QzJELHVCQUE4QyxFQUFFO2FBQ2hESyxjQUF1QjthQUN2QnBCLGVBQXVCO2FBQ3ZCbUIsU0FBaUI7YUFDakJwQyxXQUFxQjthQUNyQnVFLGtCQUEyQjthQUMzQlIscUJBQThDOztBQW9jeEQ7QUFFQSw0QkFBNEI7QUFDckIsTUFBTTJCLGdCQUFnQixJQUFJdkgsZ0JBQWdCO0FBQ2pELCtEQUFldUgsYUFBYUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL3dlYnJ0Yy50cz8zMWQ1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcclxuXHJcbmltcG9ydCB7IHNvY2tldFNlcnZpY2UgfSBmcm9tICcuL3NvY2tldCc7XHJcblxyXG4vLyBJQ0Ugc2VydmVycyBjb25maWd1cmF0aW9uIGZvciBTVFVOL1RVUk5cclxuY29uc3QgSUNFX1NFUlZFUlM6IFJUQ0NvbmZpZ3VyYXRpb24gPSB7XHJcbiAgaWNlU2VydmVyczogW1xyXG4gICAgeyB1cmxzOiAnc3R1bjpzdHVuLmwuZ29vZ2xlLmNvbToxOTMwMicgfSxcclxuICAgIHsgdXJsczogJ3N0dW46c3R1bjEubC5nb29nbGUuY29tOjE5MzAyJyB9LFxyXG4gICAgeyB1cmxzOiAnc3R1bjpzdHVuMi5sLmdvb2dsZS5jb206MTkzMDInIH0sXHJcbiAgICB7IHVybHM6ICdzdHVuOnN0dW4zLmwuZ29vZ2xlLmNvbToxOTMwMicgfSxcclxuICAgIHsgdXJsczogJ3N0dW46c3R1bjQubC5nb29nbGUuY29tOjE5MzAyJyB9LFxyXG4gIF0sXHJcbiAgaWNlQ2FuZGlkYXRlUG9vbFNpemU6IDEwLFxyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgQ2FsbFR5cGUgPSAnYXVkaW8nIHwgJ3ZpZGVvJztcclxuXHJcbmludGVyZmFjZSBXZWJSVENDYWxsYmFja3Mge1xyXG4gIG9uTG9jYWxTdHJlYW06IChzdHJlYW06IE1lZGlhU3RyZWFtKSA9PiB2b2lkO1xyXG4gIG9uUmVtb3RlU3RyZWFtOiAoc3RyZWFtOiBNZWRpYVN0cmVhbSwgcGVlcklkOiBzdHJpbmcpID0+IHZvaWQ7XHJcbiAgb25Db25uZWN0aW9uU3RhdGVDaGFuZ2U6IChzdGF0ZTogUlRDUGVlckNvbm5lY3Rpb25TdGF0ZSkgPT4gdm9pZDtcclxuICBvbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZTogKHN0YXRlOiBSVENJY2VDb25uZWN0aW9uU3RhdGUpID0+IHZvaWQ7XHJcbiAgb25DYWxsRW5kZWQ6ICgpID0+IHZvaWQ7XHJcbiAgb25FcnJvcjogKGVycm9yOiBFcnJvcikgPT4gdm9pZDtcclxufVxyXG5cclxuLy8gQ2hlY2sgaWYgV2ViUlRDIGlzIHN1cHBvcnRlZCBhbmQgd2UncmUgaW4gYSBzZWN1cmUgY29udGV4dFxyXG5mdW5jdGlvbiBjaGVja1dlYlJUQ1N1cHBvcnQoKTogeyBzdXBwb3J0ZWQ6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nIH0ge1xyXG4gIC8vIENoZWNrIGlmIHdlJ3JlIGluIGEgYnJvd3NlciBlbnZpcm9ubWVudFxyXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgcmV0dXJuIHsgc3VwcG9ydGVkOiBmYWxzZSwgZXJyb3I6ICdOb3QgaW4gYnJvd3NlciBlbnZpcm9ubWVudCcgfTtcclxuICB9XHJcblxyXG4gIC8vIENoZWNrIGZvciBzZWN1cmUgY29udGV4dCAoSFRUUFMgb3IgbG9jYWxob3N0KVxyXG4gIGlmICghd2luZG93LmlzU2VjdXJlQ29udGV4dCkge1xyXG4gICAgY29uc3QgaXNMb2NhbGhvc3QgPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgPT09ICdsb2NhbGhvc3QnIHx8IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgPT09ICcxMjcuMC4wLjEnO1xyXG4gICAgaWYgKCFpc0xvY2FsaG9zdCkge1xyXG4gICAgICByZXR1cm4geyBcclxuICAgICAgICBzdXBwb3J0ZWQ6IGZhbHNlLCBcclxuICAgICAgICBlcnJvcjogJ1dlYlJUQyByZXF1aXJlcyBIVFRQUy4gUGxlYXNlIGFjY2VzcyB2aWEgbG9jYWxob3N0OjMwMDQgb3IgdXNlIEhUVFBTLicgXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBDaGVjayBmb3IgbWVkaWFEZXZpY2VzIEFQSVxyXG4gIGlmICghbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyB8fCAhbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpIHtcclxuICAgIHJldHVybiB7IFxyXG4gICAgICBzdXBwb3J0ZWQ6IGZhbHNlLCBcclxuICAgICAgZXJyb3I6ICdZb3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBXZWJSVEMuIFBsZWFzZSB1c2UgYSBtb2Rlcm4gYnJvd3NlciBsaWtlIENocm9tZSwgRmlyZWZveCwgb3IgRWRnZS4nIFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIENoZWNrIGZvciBSVENQZWVyQ29ubmVjdGlvblxyXG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XHJcbiAgICByZXR1cm4geyBcclxuICAgICAgc3VwcG9ydGVkOiBmYWxzZSwgXHJcbiAgICAgIGVycm9yOiAnV2ViUlRDIGlzIG5vdCBmdWxseSBzdXBwb3J0ZWQgaW4geW91ciBicm93c2VyLicgXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHsgc3VwcG9ydGVkOiB0cnVlIH07XHJcbn1cclxuXHJcbmNsYXNzIFdlYlJUQ1NlcnZpY2Uge1xyXG4gIHByaXZhdGUgcGVlckNvbm5lY3Rpb246IFJUQ1BlZXJDb25uZWN0aW9uIHwgbnVsbCA9IG51bGw7XHJcbiAgcHJpdmF0ZSBsb2NhbFN0cmVhbTogTWVkaWFTdHJlYW0gfCBudWxsID0gbnVsbDtcclxuICBwcml2YXRlIHJlbW90ZVN0cmVhbTogTWVkaWFTdHJlYW0gfCBudWxsID0gbnVsbDtcclxuICBwcml2YXRlIHNjcmVlblN0cmVhbTogTWVkaWFTdHJlYW0gfCBudWxsID0gbnVsbDtcclxuICBwcml2YXRlIGNhbGxiYWNrczogUGFydGlhbDxXZWJSVENDYWxsYmFja3M+ID0ge307XHJcbiAgcHJpdmF0ZSBwZW5kaW5nSWNlQ2FuZGlkYXRlczogUlRDSWNlQ2FuZGlkYXRlSW5pdFtdID0gW107XHJcbiAgcHJpdmF0ZSBpc0luaXRpYXRvcjogYm9vbGVhbiA9IGZhbHNlO1xyXG4gIHByaXZhdGUgcmVtb3RlVXNlcklkOiBzdHJpbmcgPSAnJztcclxuICBwcml2YXRlIGNhbGxJZDogc3RyaW5nID0gJyc7XHJcbiAgcHJpdmF0ZSBjYWxsVHlwZTogQ2FsbFR5cGUgPSAnYXVkaW8nO1xyXG4gIHByaXZhdGUgaXNTY3JlZW5TaGFyaW5nOiBib29sZWFuID0gZmFsc2U7XHJcbiAgcHJpdmF0ZSBvcmlnaW5hbFZpZGVvVHJhY2s6IE1lZGlhU3RyZWFtVHJhY2sgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgc2V0Q2FsbGJhY2tzKGNhbGxiYWNrczogUGFydGlhbDxXZWJSVENDYWxsYmFja3M+KSB7XHJcbiAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcclxuICB9XHJcblxyXG4gIGFzeW5jIGluaXRpYWxpemVNZWRpYSh0eXBlOiBDYWxsVHlwZSk6IFByb21pc2U8TWVkaWFTdHJlYW0+IHtcclxuICAgIC8vIENoZWNrIFdlYlJUQyBzdXBwb3J0IGZpcnN0XHJcbiAgICBjb25zdCBzdXBwb3J0ID0gY2hlY2tXZWJSVENTdXBwb3J0KCk7XHJcbiAgICBpZiAoIXN1cHBvcnQuc3VwcG9ydGVkKSB7XHJcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKHN1cHBvcnQuZXJyb3IgfHwgJ1dlYlJUQyBub3Qgc3VwcG9ydGVkJyk7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBXZWJSVEMgbm90IHN1cHBvcnRlZDonLCBzdXBwb3J0LmVycm9yKTtcclxuICAgICAgdGhpcy5jYWxsYmFja3Mub25FcnJvcj8uKGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gU3RvcCBhbnkgZXhpc3Rpbmcgc3RyZWFtcyBmaXJzdFxyXG4gICAgICB0aGlzLnN0b3BMb2NhbFN0cmVhbSgpO1xyXG5cclxuICAgICAgY29uc3QgY29uc3RyYWludHM6IE1lZGlhU3RyZWFtQ29uc3RyYWludHMgPSB7XHJcbiAgICAgICAgYXVkaW86IHtcclxuICAgICAgICAgIGVjaG9DYW5jZWxsYXRpb246IHRydWUsXHJcbiAgICAgICAgICBub2lzZVN1cHByZXNzaW9uOiB0cnVlLFxyXG4gICAgICAgICAgYXV0b0dhaW5Db250cm9sOiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmlkZW86IHR5cGUgPT09ICd2aWRlbycgPyB7XHJcbiAgICAgICAgICB3aWR0aDogeyBpZGVhbDogMTI4MCwgbWF4OiAxOTIwIH0sXHJcbiAgICAgICAgICBoZWlnaHQ6IHsgaWRlYWw6IDcyMCwgbWF4OiAxMDgwIH0sXHJcbiAgICAgICAgICBmcmFtZVJhdGU6IHsgaWRlYWw6IDMwLCBtYXg6IDYwIH0sXHJcbiAgICAgICAgICBmYWNpbmdNb2RlOiAndXNlcicsXHJcbiAgICAgICAgfSA6IGZhbHNlLFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgY29uc29sZS5sb2coJ/Cfk7kgUmVxdWVzdGluZyBtZWRpYSB3aXRoIGNvbnN0cmFpbnRzOicsIGNvbnN0cmFpbnRzKTtcclxuICAgICAgdGhpcy5sb2NhbFN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcclxuICAgICAgY29uc29sZS5sb2coJ+KchSBHb3QgbG9jYWwgc3RyZWFtOicsIHRoaXMubG9jYWxTdHJlYW0uZ2V0VHJhY2tzKCkubWFwKHQgPT4gYCR7dC5raW5kfTogJHt0LmxhYmVsfWApKTtcclxuICAgICAgXHJcbiAgICAgIHRoaXMuY2FsbFR5cGUgPSB0eXBlO1xyXG4gICAgICB0aGlzLmNhbGxiYWNrcy5vbkxvY2FsU3RyZWFtPy4odGhpcy5sb2NhbFN0cmVhbSk7XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gdGhpcy5sb2NhbFN0cmVhbTtcclxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGFjY2Vzc2luZyBtZWRpYSBkZXZpY2VzOicsIGVycm9yKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFByb3ZpZGUgdXNlci1mcmllbmRseSBlcnJvciBtZXNzYWdlc1xyXG4gICAgICBsZXQgZXJyb3JNZXNzYWdlID0gJ0ZhaWxlZCB0byBhY2Nlc3MgY2FtZXJhL21pY3JvcGhvbmUnO1xyXG4gICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ05vdEFsbG93ZWRFcnJvcicgfHwgZXJyb3IubmFtZSA9PT0gJ1Blcm1pc3Npb25EZW5pZWRFcnJvcicpIHtcclxuICAgICAgICBlcnJvck1lc3NhZ2UgPSAnQ2FtZXJhL21pY3JvcGhvbmUgcGVybWlzc2lvbiBkZW5pZWQuIFBsZWFzZSBhbGxvdyBhY2Nlc3MgaW4geW91ciBicm93c2VyIHNldHRpbmdzLic7XHJcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ05vdEZvdW5kRXJyb3InIHx8IGVycm9yLm5hbWUgPT09ICdEZXZpY2VzTm90Rm91bmRFcnJvcicpIHtcclxuICAgICAgICBlcnJvck1lc3NhZ2UgPSAnTm8gY2FtZXJhIG9yIG1pY3JvcGhvbmUgZm91bmQuIFBsZWFzZSBjb25uZWN0IGEgZGV2aWNlIGFuZCB0cnkgYWdhaW4uJztcclxuICAgICAgfSBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnTm90UmVhZGFibGVFcnJvcicgfHwgZXJyb3IubmFtZSA9PT0gJ1RyYWNrU3RhcnRFcnJvcicpIHtcclxuICAgICAgICBlcnJvck1lc3NhZ2UgPSAnQ2FtZXJhL21pY3JvcGhvbmUgaXMgYWxyZWFkeSBpbiB1c2UgYnkgYW5vdGhlciBhcHBsaWNhdGlvbi4nO1xyXG4gICAgICB9IGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdPdmVyY29uc3RyYWluZWRFcnJvcicpIHtcclxuICAgICAgICBlcnJvck1lc3NhZ2UgPSAnQ2FtZXJhIGRvZXMgbm90IHN1cHBvcnQgdGhlIHJlcXVlc3RlZCB2aWRlbyBxdWFsaXR5Lic7XHJcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ1R5cGVFcnJvcicpIHtcclxuICAgICAgICBlcnJvck1lc3NhZ2UgPSAnV2ViUlRDIHJlcXVpcmVzIEhUVFBTLiBQbGVhc2UgYWNjZXNzIHZpYSBsb2NhbGhvc3Q6MzAwNCc7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGN1c3RvbUVycm9yID0gbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XHJcbiAgICAgIHRoaXMuY2FsbGJhY2tzLm9uRXJyb3I/LihjdXN0b21FcnJvcik7XHJcbiAgICAgIHRocm93IGN1c3RvbUVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgY3JlYXRlUGVlckNvbm5lY3Rpb24oKTogUHJvbWlzZTxSVENQZWVyQ29ubmVjdGlvbj4ge1xyXG4gICAgaWYgKHRoaXMucGVlckNvbm5lY3Rpb24pIHtcclxuICAgICAgY29uc29sZS5sb2coJ+KZu++4jyBDbG9zaW5nIGV4aXN0aW5nIHBlZXIgY29ubmVjdGlvbicpO1xyXG4gICAgICB0aGlzLnBlZXJDb25uZWN0aW9uLmNsb3NlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coJ/CflJcgQ3JlYXRpbmcgbmV3IFJUQ1BlZXJDb25uZWN0aW9uJyk7XHJcbiAgICB0aGlzLnBlZXJDb25uZWN0aW9uID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKElDRV9TRVJWRVJTKTtcclxuXHJcbiAgICAvLyBBZGQgbG9jYWwgdHJhY2tzIHRvIHBlZXIgY29ubmVjdGlvblxyXG4gICAgaWYgKHRoaXMubG9jYWxTdHJlYW0pIHtcclxuICAgICAgdGhpcy5sb2NhbFN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZyhg4p6VIEFkZGluZyAke3RyYWNrLmtpbmR9IHRyYWNrIHRvIHBlZXIgY29ubmVjdGlvbmApO1xyXG4gICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24hLmFkZFRyYWNrKHRyYWNrLCB0aGlzLmxvY2FsU3RyZWFtISk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEhhbmRsZSBpbmNvbWluZyB0cmFja3NcclxuICAgIHRoaXMucGVlckNvbm5lY3Rpb24ub250cmFjayA9IChldmVudCkgPT4ge1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+TpSBSZWNlaXZlZCByZW1vdGUgdHJhY2s6JywgZXZlbnQudHJhY2sua2luZCk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoIXRoaXMucmVtb3RlU3RyZWFtKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdGVTdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgZXZlbnQuc3RyZWFtc1swXS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZyhg4p6VIEFkZGluZyByZW1vdGUgJHt0cmFjay5raW5kfSB0cmFja2ApO1xyXG4gICAgICAgIHRoaXMucmVtb3RlU3RyZWFtIS5hZGRUcmFjayh0cmFjayk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgdGhpcy5jYWxsYmFja3Mub25SZW1vdGVTdHJlYW0/Lih0aGlzLnJlbW90ZVN0cmVhbSwgdGhpcy5yZW1vdGVVc2VySWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBIYW5kbGUgSUNFIGNhbmRpZGF0ZXNcclxuICAgIHRoaXMucGVlckNvbm5lY3Rpb24ub25pY2VjYW5kaWRhdGUgPSAoZXZlbnQpID0+IHtcclxuICAgICAgaWYgKGV2ZW50LmNhbmRpZGF0ZSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn6eKIFNlbmRpbmcgSUNFIGNhbmRpZGF0ZScpO1xyXG4gICAgICAgIHNvY2tldFNlcnZpY2Uuc2VuZEljZUNhbmRpZGF0ZSh7XHJcbiAgICAgICAgICBjYW5kaWRhdGU6IGV2ZW50LmNhbmRpZGF0ZS50b0pTT04oKSxcclxuICAgICAgICAgIHRvOiB0aGlzLnJlbW90ZVVzZXJJZCxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBIYW5kbGUgY29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2VzXHJcbiAgICB0aGlzLnBlZXJDb25uZWN0aW9uLm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gKCkgPT4ge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMucGVlckNvbm5lY3Rpb24/LmNvbm5lY3Rpb25TdGF0ZTtcclxuICAgICAgY29uc29sZS5sb2coJ/CflIQgQ29ubmVjdGlvbiBzdGF0ZTonLCBzdGF0ZSk7XHJcbiAgICAgIHRoaXMuY2FsbGJhY2tzLm9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlPy4oc3RhdGUgYXMgUlRDUGVlckNvbm5lY3Rpb25TdGF0ZSk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoc3RhdGUgPT09ICdmYWlsZWQnIHx8IHN0YXRlID09PSAnZGlzY29ubmVjdGVkJyB8fCBzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygn8J+TtCBDb25uZWN0aW9uIGVuZGVkIHdpdGggc3RhdGU6Jywgc3RhdGUpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEhhbmRsZSBJQ0UgY29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2VzXHJcbiAgICB0aGlzLnBlZXJDb25uZWN0aW9uLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gKCkgPT4ge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMucGVlckNvbm5lY3Rpb24/LmljZUNvbm5lY3Rpb25TdGF0ZTtcclxuICAgICAgY29uc29sZS5sb2coJ/Cfp4ogSUNFIGNvbm5lY3Rpb24gc3RhdGU6Jywgc3RhdGUpO1xyXG4gICAgICB0aGlzLmNhbGxiYWNrcy5vbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZT8uKHN0YXRlIGFzIFJUQ0ljZUNvbm5lY3Rpb25TdGF0ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEhhbmRsZSBJQ0UgZ2F0aGVyaW5nIHN0YXRlIGNoYW5nZXNcclxuICAgIHRoaXMucGVlckNvbm5lY3Rpb24ub25pY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZSA9ICgpID0+IHtcclxuICAgICAgY29uc29sZS5sb2coJ/Cfp4ogSUNFIGdhdGhlcmluZyBzdGF0ZTonLCB0aGlzLnBlZXJDb25uZWN0aW9uPy5pY2VHYXRoZXJpbmdTdGF0ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFByb2Nlc3MgYW55IHBlbmRpbmcgSUNFIGNhbmRpZGF0ZXNcclxuICAgIGlmICh0aGlzLnBlbmRpbmdJY2VDYW5kaWRhdGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uc29sZS5sb2coYPCfk6YgUHJvY2Vzc2luZyAke3RoaXMucGVuZGluZ0ljZUNhbmRpZGF0ZXMubGVuZ3RofSBwZW5kaW5nIElDRSBjYW5kaWRhdGVzYCk7XHJcbiAgICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIHRoaXMucGVuZGluZ0ljZUNhbmRpZGF0ZXMpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLmFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMucGVuZGluZ0ljZUNhbmRpZGF0ZXMgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5wZWVyQ29ubmVjdGlvbjtcclxuICB9XHJcblxyXG4gIGFzeW5jIGluaXRpYXRlQ2FsbChyZW1vdGVVc2VySWQ6IHN0cmluZywgY2FsbElkOiBzdHJpbmcsIHR5cGU6IENhbGxUeXBlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zb2xlLmxvZyhg8J+TniBJbml0aWF0aW5nICR7dHlwZX0gY2FsbCB0byAke3JlbW90ZVVzZXJJZH1gKTtcclxuICAgIFxyXG4gICAgdGhpcy5pc0luaXRpYXRvciA9IHRydWU7XHJcbiAgICB0aGlzLnJlbW90ZVVzZXJJZCA9IHJlbW90ZVVzZXJJZDtcclxuICAgIHRoaXMuY2FsbElkID0gY2FsbElkO1xyXG4gICAgdGhpcy5jYWxsVHlwZSA9IHR5cGU7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gSW5pdGlhbGl6ZSBtZWRpYSBmaXJzdFxyXG4gICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVNZWRpYSh0eXBlKTtcclxuICAgICAgXHJcbiAgICAgIC8vIENyZWF0ZSBwZWVyIGNvbm5lY3Rpb25cclxuICAgICAgYXdhaXQgdGhpcy5jcmVhdGVQZWVyQ29ubmVjdGlvbigpO1xyXG5cclxuICAgICAgLy8gQ3JlYXRlIGFuZCBzZW5kIG9mZmVyXHJcbiAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5wZWVyQ29ubmVjdGlvbiEuY3JlYXRlT2ZmZXIoe1xyXG4gICAgICAgIG9mZmVyVG9SZWNlaXZlQXVkaW86IHRydWUsXHJcbiAgICAgICAgb2ZmZXJUb1JlY2VpdmVWaWRlbzogdHlwZSA9PT0gJ3ZpZGVvJyxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zb2xlLmxvZygn8J+TpCBDcmVhdGVkIG9mZmVyOicsIG9mZmVyLnR5cGUpO1xyXG4gICAgICBhd2FpdCB0aGlzLnBlZXJDb25uZWN0aW9uIS5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcclxuXHJcbiAgICAgIC8vIFNlbmQgY2FsbCBzaWduYWwgdG8gcmVtb3RlIHVzZXJcclxuICAgICAgc29ja2V0U2VydmljZS5jYWxsVXNlcih7XHJcbiAgICAgICAgdXNlclRvQ2FsbDogcmVtb3RlVXNlcklkLFxyXG4gICAgICAgIHNpZ25hbERhdGE6IG9mZmVyLFxyXG4gICAgICAgIGNhbGxUeXBlOiB0eXBlLFxyXG4gICAgICAgIGNhbGxJZDogY2FsbElkLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OkIFNlbnQgY2FsbCBzaWduYWwgdG86JywgcmVtb3RlVXNlcklkKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBpbml0aWF0aW5nIGNhbGw6JywgZXJyb3IpO1xyXG4gICAgICB0aGlzLmNhbGxiYWNrcy5vbkVycm9yPy4oZXJyb3IgYXMgRXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGFjY2VwdENhbGwoXHJcbiAgICByZW1vdGVVc2VySWQ6IHN0cmluZyxcclxuICAgIGNhbGxJZDogc3RyaW5nLFxyXG4gICAgdHlwZTogQ2FsbFR5cGUsXHJcbiAgICBvZmZlcjogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdFxyXG4gICk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc29sZS5sb2coYPCfk54gQWNjZXB0aW5nICR7dHlwZX0gY2FsbCBmcm9tICR7cmVtb3RlVXNlcklkfWApO1xyXG4gICAgXHJcbiAgICB0aGlzLmlzSW5pdGlhdG9yID0gZmFsc2U7XHJcbiAgICB0aGlzLnJlbW90ZVVzZXJJZCA9IHJlbW90ZVVzZXJJZDtcclxuICAgIHRoaXMuY2FsbElkID0gY2FsbElkO1xyXG4gICAgdGhpcy5jYWxsVHlwZSA9IHR5cGU7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gSW5pdGlhbGl6ZSBtZWRpYSBmaXJzdFxyXG4gICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVNZWRpYSh0eXBlKTtcclxuICAgICAgXHJcbiAgICAgIC8vIENyZWF0ZSBwZWVyIGNvbm5lY3Rpb25cclxuICAgICAgYXdhaXQgdGhpcy5jcmVhdGVQZWVyQ29ubmVjdGlvbigpO1xyXG5cclxuICAgICAgLy8gU2V0IHJlbW90ZSBkZXNjcmlwdGlvbiAodGhlIG9mZmVyKVxyXG4gICAgICBjb25zb2xlLmxvZygn8J+TpSBTZXR0aW5nIHJlbW90ZSBkZXNjcmlwdGlvbiAob2ZmZXIpJyk7XHJcbiAgICAgIGF3YWl0IHRoaXMucGVlckNvbm5lY3Rpb24hLnNldFJlbW90ZURlc2NyaXB0aW9uKG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24ob2ZmZXIpKTtcclxuXHJcbiAgICAgIC8vIENyZWF0ZSBhbmQgc2VuZCBhbnN3ZXJcclxuICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5wZWVyQ29ubmVjdGlvbiEuY3JlYXRlQW5zd2VyKCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OkIENyZWF0ZWQgYW5zd2VyOicsIGFuc3dlci50eXBlKTtcclxuICAgICAgXHJcbiAgICAgIGF3YWl0IHRoaXMucGVlckNvbm5lY3Rpb24hLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcclxuXHJcbiAgICAgIC8vIFNlbmQgYW5zd2VyIGJhY2sgdG8gY2FsbGVyXHJcbiAgICAgIHNvY2tldFNlcnZpY2UuYW5zd2VyQ2FsbCh7XHJcbiAgICAgICAgc2lnbmFsOiBhbnN3ZXIsXHJcbiAgICAgICAgdG86IHJlbW90ZVVzZXJJZCxcclxuICAgICAgICBjYWxsSWQ6IGNhbGxJZCxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zb2xlLmxvZygn8J+TpCBTZW50IGFuc3dlciB0bzonLCByZW1vdGVVc2VySWQpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGFjY2VwdGluZyBjYWxsOicsIGVycm9yKTtcclxuICAgICAgdGhpcy5jYWxsYmFja3Mub25FcnJvcj8uKGVycm9yIGFzIEVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBoYW5kbGVBbnN3ZXIoYW5zd2VyOiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0KTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zb2xlLmxvZygn8J+TpSBIYW5kbGluZyBhbnN3ZXInKTtcclxuICAgIFxyXG4gICAgaWYgKCF0aGlzLnBlZXJDb25uZWN0aW9uKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBObyBwZWVyIGNvbm5lY3Rpb24gZXhpc3RzJyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBhd2FpdCB0aGlzLnBlZXJDb25uZWN0aW9uLnNldFJlbW90ZURlc2NyaXB0aW9uKG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24oYW5zd2VyKSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgU2V0IHJlbW90ZSBkZXNjcmlwdGlvbiAoYW5zd2VyKScpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGhhbmRsaW5nIGFuc3dlcjonLCBlcnJvcik7XHJcbiAgICAgIHRoaXMuY2FsbGJhY2tzLm9uRXJyb3I/LihlcnJvciBhcyBFcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBhZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlOiBSVENJY2VDYW5kaWRhdGVJbml0KTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBpZiAoIXRoaXMucGVlckNvbm5lY3Rpb24gfHwgIXRoaXMucGVlckNvbm5lY3Rpb24ucmVtb3RlRGVzY3JpcHRpb24pIHtcclxuICAgICAgY29uc29sZS5sb2coJ/Cfk6YgUXVldWluZyBJQ0UgY2FuZGlkYXRlIChubyByZW1vdGUgZGVzY3JpcHRpb24geWV0KScpO1xyXG4gICAgICB0aGlzLnBlbmRpbmdJY2VDYW5kaWRhdGVzLnB1c2goY2FuZGlkYXRlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IHRoaXMucGVlckNvbm5lY3Rpb24uYWRkSWNlQ2FuZGlkYXRlKG5ldyBSVENJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgQWRkZWQgSUNFIGNhbmRpZGF0ZScpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGFkZGluZyBJQ0UgY2FuZGlkYXRlOicsIGVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIHN0YXJ0U2NyZWVuU2hhcmUoKTogUHJvbWlzZTxNZWRpYVN0cmVhbSB8IG51bGw+IHtcclxuICAgIC8vIENoZWNrIFdlYlJUQyBzdXBwb3J0IGZpcnN0XHJcbiAgICBjb25zdCBzdXBwb3J0ID0gY2hlY2tXZWJSVENTdXBwb3J0KCk7XHJcbiAgICBpZiAoIXN1cHBvcnQuc3VwcG9ydGVkKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBTY3JlZW4gc2hhcmUgbm90IHN1cHBvcnRlZDonLCBzdXBwb3J0LmVycm9yKTtcclxuICAgICAgdGhpcy5jYWxsYmFja3Mub25FcnJvcj8uKG5ldyBFcnJvcihzdXBwb3J0LmVycm9yIHx8ICdTY3JlZW4gc2hhcmUgbm90IHN1cHBvcnRlZCcpKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ/CflqXvuI8gU3RhcnRpbmcgc2NyZWVuIHNoYXJlJyk7XHJcbiAgICAgIFxyXG4gICAgICB0aGlzLnNjcmVlblN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhKHtcclxuICAgICAgICB2aWRlbzoge1xyXG4gICAgICAgICAgY3Vyc29yOiAnYWx3YXlzJyxcclxuICAgICAgICB9IGFzIGFueSxcclxuICAgICAgICBhdWRpbzogZmFsc2UsIC8vIFNjcmVlbiBhdWRpbyBvZnRlbiBjYXVzZXMgaXNzdWVzXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY29uc3QgdmlkZW9UcmFjayA9IHRoaXMuc2NyZWVuU3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF07XHJcbiAgICAgIFxyXG4gICAgICAvLyBTdG9yZSBvcmlnaW5hbCB2aWRlbyB0cmFja1xyXG4gICAgICBpZiAodGhpcy5sb2NhbFN0cmVhbSkge1xyXG4gICAgICAgIHRoaXMub3JpZ2luYWxWaWRlb1RyYWNrID0gdGhpcy5sb2NhbFN0cmVhbS5nZXRWaWRlb1RyYWNrcygpWzBdIHx8IG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEhhbmRsZSB3aGVuIHVzZXIgc3RvcHMgc2hhcmluZyB2aWEgYnJvd3NlciBVSVxyXG4gICAgICB2aWRlb1RyYWNrLm9uZW5kZWQgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ/CflqXvuI8gU2NyZWVuIHNoYXJlIGVuZGVkIGJ5IHVzZXInKTtcclxuICAgICAgICB0aGlzLnN0b3BTY3JlZW5TaGFyZSgpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gUmVwbGFjZSB2aWRlbyB0cmFjayBpbiBwZWVyIGNvbm5lY3Rpb25cclxuICAgICAgaWYgKHRoaXMucGVlckNvbm5lY3Rpb24gJiYgdGhpcy5sb2NhbFN0cmVhbSkge1xyXG4gICAgICAgIGNvbnN0IHNlbmRlciA9IHRoaXMucGVlckNvbm5lY3Rpb24uZ2V0U2VuZGVycygpLmZpbmQocyA9PiBzLnRyYWNrPy5raW5kID09PSAndmlkZW8nKTtcclxuICAgICAgICBpZiAoc2VuZGVyKSB7XHJcbiAgICAgICAgICBhd2FpdCBzZW5kZXIucmVwbGFjZVRyYWNrKHZpZGVvVHJhY2spO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ+KchSBSZXBsYWNlZCB2aWRlbyB0cmFjayB3aXRoIHNjcmVlbiBzaGFyZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5pc1NjcmVlblNoYXJpbmcgPSB0cnVlO1xyXG4gICAgICByZXR1cm4gdGhpcy5zY3JlZW5TdHJlYW07XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3Igc3RhcnRpbmcgc2NyZWVuIHNoYXJlOicsIGVycm9yKTtcclxuICAgICAgdGhpcy5jYWxsYmFja3Mub25FcnJvcj8uKGVycm9yIGFzIEVycm9yKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBzdG9wU2NyZWVuU2hhcmUoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zb2xlLmxvZygn8J+Wpe+4jyBTdG9wcGluZyBzY3JlZW4gc2hhcmUnKTtcclxuICAgIFxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gU3RvcCBzY3JlZW4gc3RyZWFtIHRyYWNrc1xyXG4gICAgICBpZiAodGhpcy5zY3JlZW5TdHJlYW0pIHtcclxuICAgICAgICB0aGlzLnNjcmVlblN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHRyYWNrLnN0b3AoKSk7XHJcbiAgICAgICAgdGhpcy5zY3JlZW5TdHJlYW0gPSBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIHZpZGVvIHRyYWNrXHJcbiAgICAgIGlmICh0aGlzLnBlZXJDb25uZWN0aW9uICYmIHRoaXMub3JpZ2luYWxWaWRlb1RyYWNrKSB7XHJcbiAgICAgICAgY29uc3Qgc2VuZGVyID0gdGhpcy5wZWVyQ29ubmVjdGlvbi5nZXRTZW5kZXJzKCkuZmluZChzID0+IHMudHJhY2s/LmtpbmQgPT09ICd2aWRlbycpO1xyXG4gICAgICAgIGlmIChzZW5kZXIpIHtcclxuICAgICAgICAgIGF3YWl0IHNlbmRlci5yZXBsYWNlVHJhY2sodGhpcy5vcmlnaW5hbFZpZGVvVHJhY2spO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ+KchSBSZXN0b3JlZCBvcmlnaW5hbCB2aWRlbyB0cmFjaycpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICh0aGlzLnBlZXJDb25uZWN0aW9uICYmIHRoaXMuY2FsbFR5cGUgPT09ICd2aWRlbycpIHtcclxuICAgICAgICAvLyBSZS1hY3F1aXJlIGNhbWVyYSBpZiBvcmlnaW5hbCB0cmFjayBpcyBnb25lXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IG5ld1N0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHsgdmlkZW86IHRydWUgfSk7XHJcbiAgICAgICAgICBjb25zdCBuZXdWaWRlb1RyYWNrID0gbmV3U3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF07XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGNvbnN0IHNlbmRlciA9IHRoaXMucGVlckNvbm5lY3Rpb24uZ2V0U2VuZGVycygpLmZpbmQocyA9PiBzLnRyYWNrPy5raW5kID09PSAndmlkZW8nKTtcclxuICAgICAgICAgIGlmIChzZW5kZXIpIHtcclxuICAgICAgICAgICAgYXdhaXQgc2VuZGVyLnJlcGxhY2VUcmFjayhuZXdWaWRlb1RyYWNrKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ+KchSBBY3F1aXJlZCBuZXcgdmlkZW8gdHJhY2snKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gVXBkYXRlIGxvY2FsIHN0cmVhbVxyXG4gICAgICAgICAgaWYgKHRoaXMubG9jYWxTdHJlYW0pIHtcclxuICAgICAgICAgICAgY29uc3Qgb2xkVmlkZW9UcmFjayA9IHRoaXMubG9jYWxTdHJlYW0uZ2V0VmlkZW9UcmFja3MoKVswXTtcclxuICAgICAgICAgICAgaWYgKG9sZFZpZGVvVHJhY2spIHtcclxuICAgICAgICAgICAgICB0aGlzLmxvY2FsU3RyZWFtLnJlbW92ZVRyYWNrKG9sZFZpZGVvVHJhY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubG9jYWxTdHJlYW0uYWRkVHJhY2sobmV3VmlkZW9UcmFjayk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uTG9jYWxTdHJlYW0/Lih0aGlzLmxvY2FsU3RyZWFtKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIHJlLWFjcXVpcmluZyBjYW1lcmE6JywgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5pc1NjcmVlblNoYXJpbmcgPSBmYWxzZTtcclxuICAgICAgdGhpcy5vcmlnaW5hbFZpZGVvVHJhY2sgPSBudWxsO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIHN0b3BwaW5nIHNjcmVlbiBzaGFyZTonLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB0b2dnbGVNdXRlKCk6IGJvb2xlYW4ge1xyXG4gICAgaWYgKHRoaXMubG9jYWxTdHJlYW0pIHtcclxuICAgICAgY29uc3QgYXVkaW9UcmFjayA9IHRoaXMubG9jYWxTdHJlYW0uZ2V0QXVkaW9UcmFja3MoKVswXTtcclxuICAgICAgaWYgKGF1ZGlvVHJhY2spIHtcclxuICAgICAgICBhdWRpb1RyYWNrLmVuYWJsZWQgPSAhYXVkaW9UcmFjay5lbmFibGVkO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn46kIE1pYyAke2F1ZGlvVHJhY2suZW5hYmxlZCA/ICd1bm11dGVkJyA6ICdtdXRlZCd9YCk7XHJcbiAgICAgICAgcmV0dXJuICFhdWRpb1RyYWNrLmVuYWJsZWQ7IC8vIFJldHVybiBpc011dGVkIHN0YXRlXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHRvZ2dsZVZpZGVvKCk6IGJvb2xlYW4ge1xyXG4gICAgaWYgKHRoaXMubG9jYWxTdHJlYW0gJiYgIXRoaXMuaXNTY3JlZW5TaGFyaW5nKSB7XHJcbiAgICAgIGNvbnN0IHZpZGVvVHJhY2sgPSB0aGlzLmxvY2FsU3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF07XHJcbiAgICAgIGlmICh2aWRlb1RyYWNrKSB7XHJcbiAgICAgICAgdmlkZW9UcmFjay5lbmFibGVkID0gIXZpZGVvVHJhY2suZW5hYmxlZDtcclxuICAgICAgICBjb25zb2xlLmxvZyhg8J+TuSBWaWRlbyAke3ZpZGVvVHJhY2suZW5hYmxlZCA/ICdlbmFibGVkJyA6ICdkaXNhYmxlZCd9YCk7XHJcbiAgICAgICAgcmV0dXJuIHZpZGVvVHJhY2suZW5hYmxlZDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBnZXRJc1NjcmVlblNoYXJpbmcoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5pc1NjcmVlblNoYXJpbmc7XHJcbiAgfVxyXG5cclxuICBzdG9wTG9jYWxTdHJlYW0oKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5sb2NhbFN0cmVhbSkge1xyXG4gICAgICB0aGlzLmxvY2FsU3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xyXG4gICAgICAgIHRyYWNrLnN0b3AoKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhg4o+577iPIFN0b3BwZWQgJHt0cmFjay5raW5kfSB0cmFja2ApO1xyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5sb2NhbFN0cmVhbSA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBlbmRDYWxsKCk6IHZvaWQge1xyXG4gICAgY29uc29sZS5sb2coJ/Cfk7QgRW5kaW5nIGNhbGwnKTtcclxuICAgIFxyXG4gICAgLy8gU3RvcCBzY3JlZW4gc2hhcmUgaWYgYWN0aXZlXHJcbiAgICBpZiAodGhpcy5pc1NjcmVlblNoYXJpbmcpIHtcclxuICAgICAgdGhpcy5zdG9wU2NyZWVuU2hhcmUoKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gU3RvcCBsb2NhbCBzdHJlYW1cclxuICAgIHRoaXMuc3RvcExvY2FsU3RyZWFtKCk7XHJcbiAgICBcclxuICAgIC8vIFN0b3AgcmVtb3RlIHN0cmVhbVxyXG4gICAgaWYgKHRoaXMucmVtb3RlU3RyZWFtKSB7XHJcbiAgICAgIHRoaXMucmVtb3RlU3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4gdHJhY2suc3RvcCgpKTtcclxuICAgICAgdGhpcy5yZW1vdGVTdHJlYW0gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBDbG9zZSBwZWVyIGNvbm5lY3Rpb25cclxuICAgIGlmICh0aGlzLnBlZXJDb25uZWN0aW9uKSB7XHJcbiAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24uY2xvc2UoKTtcclxuICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbiA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFJlc2V0IHN0YXRlXHJcbiAgICB0aGlzLnBlbmRpbmdJY2VDYW5kaWRhdGVzID0gW107XHJcbiAgICB0aGlzLmlzSW5pdGlhdG9yID0gZmFsc2U7XHJcbiAgICB0aGlzLnJlbW90ZVVzZXJJZCA9ICcnO1xyXG4gICAgdGhpcy5jYWxsSWQgPSAnJztcclxuICAgIHRoaXMub3JpZ2luYWxWaWRlb1RyYWNrID0gbnVsbDtcclxuICAgIHRoaXMuaXNTY3JlZW5TaGFyaW5nID0gZmFsc2U7XHJcbiAgICBcclxuICAgIHRoaXMuY2FsbGJhY2tzLm9uQ2FsbEVuZGVkPy4oKTtcclxuICB9XHJcblxyXG4gIGdldExvY2FsU3RyZWFtKCk6IE1lZGlhU3RyZWFtIHwgbnVsbCB7XHJcbiAgICByZXR1cm4gdGhpcy5sb2NhbFN0cmVhbTtcclxuICB9XHJcblxyXG4gIGdldFJlbW90ZVN0cmVhbSgpOiBNZWRpYVN0cmVhbSB8IG51bGwge1xyXG4gICAgcmV0dXJuIHRoaXMucmVtb3RlU3RyZWFtO1xyXG4gIH1cclxuXHJcbiAgZ2V0UGVlckNvbm5lY3Rpb24oKTogUlRDUGVlckNvbm5lY3Rpb24gfCBudWxsIHtcclxuICAgIHJldHVybiB0aGlzLnBlZXJDb25uZWN0aW9uO1xyXG4gIH1cclxuXHJcbiAgZ2V0Q2FsbElkKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdGhpcy5jYWxsSWQ7XHJcbiAgfVxyXG5cclxuICBnZXRSZW1vdGVVc2VySWQoKTogc3RyaW5nIHtcclxuICAgIHJldHVybiB0aGlzLnJlbW90ZVVzZXJJZDtcclxuICB9XHJcbn1cclxuXHJcbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcclxuZXhwb3J0IGNvbnN0IHdlYlJUQ1NlcnZpY2UgPSBuZXcgV2ViUlRDU2VydmljZSgpO1xyXG5leHBvcnQgZGVmYXVsdCB3ZWJSVENTZXJ2aWNlO1xyXG5cclxuIl0sIm5hbWVzIjpbInNvY2tldFNlcnZpY2UiLCJJQ0VfU0VSVkVSUyIsImljZVNlcnZlcnMiLCJ1cmxzIiwiaWNlQ2FuZGlkYXRlUG9vbFNpemUiLCJjaGVja1dlYlJUQ1N1cHBvcnQiLCJzdXBwb3J0ZWQiLCJlcnJvciIsIndpbmRvdyIsImlzU2VjdXJlQ29udGV4dCIsImlzTG9jYWxob3N0IiwibG9jYXRpb24iLCJob3N0bmFtZSIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImdldFVzZXJNZWRpYSIsIlJUQ1BlZXJDb25uZWN0aW9uIiwiV2ViUlRDU2VydmljZSIsInNldENhbGxiYWNrcyIsImNhbGxiYWNrcyIsImluaXRpYWxpemVNZWRpYSIsInR5cGUiLCJzdXBwb3J0IiwiRXJyb3IiLCJjb25zb2xlIiwib25FcnJvciIsInN0b3BMb2NhbFN0cmVhbSIsImNvbnN0cmFpbnRzIiwiYXVkaW8iLCJlY2hvQ2FuY2VsbGF0aW9uIiwibm9pc2VTdXBwcmVzc2lvbiIsImF1dG9HYWluQ29udHJvbCIsInZpZGVvIiwid2lkdGgiLCJpZGVhbCIsIm1heCIsImhlaWdodCIsImZyYW1lUmF0ZSIsImZhY2luZ01vZGUiLCJsb2ciLCJsb2NhbFN0cmVhbSIsImdldFRyYWNrcyIsIm1hcCIsInQiLCJraW5kIiwibGFiZWwiLCJjYWxsVHlwZSIsIm9uTG9jYWxTdHJlYW0iLCJlcnJvck1lc3NhZ2UiLCJuYW1lIiwiY3VzdG9tRXJyb3IiLCJjcmVhdGVQZWVyQ29ubmVjdGlvbiIsInBlZXJDb25uZWN0aW9uIiwiY2xvc2UiLCJmb3JFYWNoIiwidHJhY2siLCJhZGRUcmFjayIsIm9udHJhY2siLCJldmVudCIsInJlbW90ZVN0cmVhbSIsIk1lZGlhU3RyZWFtIiwic3RyZWFtcyIsIm9uUmVtb3RlU3RyZWFtIiwicmVtb3RlVXNlcklkIiwib25pY2VjYW5kaWRhdGUiLCJjYW5kaWRhdGUiLCJzZW5kSWNlQ2FuZGlkYXRlIiwidG9KU09OIiwidG8iLCJvbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSIsInN0YXRlIiwiY29ubmVjdGlvblN0YXRlIiwib25Db25uZWN0aW9uU3RhdGVDaGFuZ2UiLCJvbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSIsImljZUNvbm5lY3Rpb25TdGF0ZSIsIm9uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlIiwib25pY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZSIsImljZUdhdGhlcmluZ1N0YXRlIiwicGVuZGluZ0ljZUNhbmRpZGF0ZXMiLCJsZW5ndGgiLCJhZGRJY2VDYW5kaWRhdGUiLCJpbml0aWF0ZUNhbGwiLCJjYWxsSWQiLCJpc0luaXRpYXRvciIsIm9mZmVyIiwiY3JlYXRlT2ZmZXIiLCJvZmZlclRvUmVjZWl2ZUF1ZGlvIiwib2ZmZXJUb1JlY2VpdmVWaWRlbyIsInNldExvY2FsRGVzY3JpcHRpb24iLCJjYWxsVXNlciIsInVzZXJUb0NhbGwiLCJzaWduYWxEYXRhIiwiYWNjZXB0Q2FsbCIsInNldFJlbW90ZURlc2NyaXB0aW9uIiwiUlRDU2Vzc2lvbkRlc2NyaXB0aW9uIiwiYW5zd2VyIiwiY3JlYXRlQW5zd2VyIiwiYW5zd2VyQ2FsbCIsInNpZ25hbCIsImhhbmRsZUFuc3dlciIsInJlbW90ZURlc2NyaXB0aW9uIiwicHVzaCIsIlJUQ0ljZUNhbmRpZGF0ZSIsInN0YXJ0U2NyZWVuU2hhcmUiLCJzY3JlZW5TdHJlYW0iLCJnZXREaXNwbGF5TWVkaWEiLCJjdXJzb3IiLCJ2aWRlb1RyYWNrIiwiZ2V0VmlkZW9UcmFja3MiLCJvcmlnaW5hbFZpZGVvVHJhY2siLCJvbmVuZGVkIiwic3RvcFNjcmVlblNoYXJlIiwic2VuZGVyIiwiZ2V0U2VuZGVycyIsImZpbmQiLCJzIiwicmVwbGFjZVRyYWNrIiwiaXNTY3JlZW5TaGFyaW5nIiwic3RvcCIsIm5ld1N0cmVhbSIsIm5ld1ZpZGVvVHJhY2siLCJvbGRWaWRlb1RyYWNrIiwicmVtb3ZlVHJhY2siLCJ0b2dnbGVNdXRlIiwiYXVkaW9UcmFjayIsImdldEF1ZGlvVHJhY2tzIiwiZW5hYmxlZCIsInRvZ2dsZVZpZGVvIiwiZ2V0SXNTY3JlZW5TaGFyaW5nIiwiZW5kQ2FsbCIsIm9uQ2FsbEVuZGVkIiwiZ2V0TG9jYWxTdHJlYW0iLCJnZXRSZW1vdGVTdHJlYW0iLCJnZXRQZWVyQ29ubmVjdGlvbiIsImdldENhbGxJZCIsImdldFJlbW90ZVVzZXJJZCIsIndlYlJUQ1NlcnZpY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/webrtc.ts\n"));

/***/ })

});