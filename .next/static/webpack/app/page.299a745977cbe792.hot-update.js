"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/webrtc.ts":
/*!***************************!*\
  !*** ./src/lib/webrtc.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   webRTCService: function() { return /* binding */ webRTCService; }\n/* harmony export */ });\n/* harmony import */ var _socket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./socket */ \"(app-pages-browser)/./src/lib/socket.ts\");\n/* __next_internal_client_entry_do_not_use__ webRTCService,default auto */ \n// ICE servers configuration for STUN/TURN\nconst ICE_SERVERS = {\n    iceServers: [\n        {\n            urls: \"stun:stun.l.google.com:19302\"\n        },\n        {\n            urls: \"stun:stun1.l.google.com:19302\"\n        },\n        {\n            urls: \"stun:stun2.l.google.com:19302\"\n        },\n        {\n            urls: \"stun:stun3.l.google.com:19302\"\n        },\n        {\n            urls: \"stun:stun4.l.google.com:19302\"\n        }\n    ],\n    iceCandidatePoolSize: 10\n};\n// Check if WebRTC is supported and we're in a secure context\nfunction checkWebRTCSupport() {\n    // Check if we're in a browser environment\n    if (false) {}\n    // Check for secure context (HTTPS or localhost)\n    if (!window.isSecureContext) {\n        const isLocalhost = window.location.hostname === \"localhost\" || window.location.hostname === \"127.0.0.1\";\n        if (!isLocalhost) {\n            return {\n                supported: false,\n                error: \"WebRTC requires HTTPS. Please access via localhost:3004 or use HTTPS.\"\n            };\n        }\n    }\n    // Check for mediaDevices API\n    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n        return {\n            supported: false,\n            error: \"Your browser does not support WebRTC. Please use a modern browser like Chrome, Firefox, or Edge.\"\n        };\n    }\n    // Check for RTCPeerConnection\n    if (!window.RTCPeerConnection) {\n        return {\n            supported: false,\n            error: \"WebRTC is not fully supported in your browser.\"\n        };\n    }\n    return {\n        supported: true\n    };\n}\nclass WebRTCService {\n    setCallbacks(callbacks) {\n        this.callbacks = callbacks;\n    }\n    async initializeMedia(type) {\n        // Check WebRTC support first\n        const support = checkWebRTCSupport();\n        if (!support.supported) {\n            var _this_callbacks_onError, _this_callbacks;\n            const error = new Error(support.error || \"WebRTC not supported\");\n            console.error(\"❌ WebRTC not supported:\", support.error);\n            (_this_callbacks_onError = (_this_callbacks = this.callbacks).onError) === null || _this_callbacks_onError === void 0 ? void 0 : _this_callbacks_onError.call(_this_callbacks, error);\n            throw error;\n        }\n        try {\n            var _this_callbacks_onLocalStream, _this_callbacks1;\n            // Stop any existing streams first\n            this.stopLocalStream();\n            const constraints = {\n                audio: {\n                    echoCancellation: true,\n                    noiseSuppression: true,\n                    autoGainControl: true\n                },\n                video: type === \"video\" ? {\n                    width: {\n                        ideal: 1280,\n                        max: 1920\n                    },\n                    height: {\n                        ideal: 720,\n                        max: 1080\n                    },\n                    frameRate: {\n                        ideal: 30,\n                        max: 60\n                    },\n                    facingMode: \"user\"\n                } : false\n            };\n            console.log(\"\\uD83D\\uDCF9 Requesting media with constraints:\", constraints);\n            this.localStream = await navigator.mediaDevices.getUserMedia(constraints);\n            console.log(\"✅ Got local stream:\", this.localStream.getTracks().map((t)=>\"\".concat(t.kind, \": \").concat(t.label)));\n            this.callType = type;\n            (_this_callbacks_onLocalStream = (_this_callbacks1 = this.callbacks).onLocalStream) === null || _this_callbacks_onLocalStream === void 0 ? void 0 : _this_callbacks_onLocalStream.call(_this_callbacks1, this.localStream);\n            return this.localStream;\n        } catch (error) {\n            var _this_callbacks_onError1, _this_callbacks2;\n            console.error(\"❌ Error accessing media devices:\", error);\n            // Provide user-friendly error messages\n            let errorMessage = \"Failed to access camera/microphone\";\n            if (error.name === \"NotAllowedError\" || error.name === \"PermissionDeniedError\") {\n                errorMessage = \"Camera/microphone permission denied. Please allow access in your browser settings.\";\n            } else if (error.name === \"NotFoundError\" || error.name === \"DevicesNotFoundError\") {\n                errorMessage = \"No camera or microphone found. Please connect a device and try again.\";\n            } else if (error.name === \"NotReadableError\" || error.name === \"TrackStartError\") {\n                errorMessage = \"Camera/microphone is already in use by another application.\";\n            } else if (error.name === \"OverconstrainedError\") {\n                errorMessage = \"Camera does not support the requested video quality.\";\n            } else if (error.name === \"TypeError\") {\n                errorMessage = \"WebRTC requires HTTPS. Please access via localhost:3004\";\n            }\n            const customError = new Error(errorMessage);\n            (_this_callbacks_onError1 = (_this_callbacks2 = this.callbacks).onError) === null || _this_callbacks_onError1 === void 0 ? void 0 : _this_callbacks_onError1.call(_this_callbacks2, customError);\n            throw customError;\n        }\n    }\n    async createPeerConnection() {\n        if (this.peerConnection) {\n            console.log(\"♻️ Closing existing peer connection\");\n            this.peerConnection.close();\n        }\n        console.log(\"\\uD83D\\uDD17 Creating new RTCPeerConnection\");\n        this.peerConnection = new RTCPeerConnection(ICE_SERVERS);\n        // Add local tracks to peer connection\n        if (this.localStream) {\n            this.localStream.getTracks().forEach((track)=>{\n                console.log(\"➕ Adding \".concat(track.kind, \" track to peer connection\"));\n                this.peerConnection.addTrack(track, this.localStream);\n            });\n        }\n        // Handle incoming tracks\n        this.peerConnection.ontrack = (event)=>{\n            var _this_callbacks_onRemoteStream, _this_callbacks;\n            console.log(\"\\uD83D\\uDCE5 Received remote track:\", event.track.kind);\n            if (!this.remoteStream) {\n                this.remoteStream = new MediaStream();\n            }\n            event.streams[0].getTracks().forEach((track)=>{\n                console.log(\"➕ Adding remote \".concat(track.kind, \" track\"));\n                this.remoteStream.addTrack(track);\n            });\n            (_this_callbacks_onRemoteStream = (_this_callbacks = this.callbacks).onRemoteStream) === null || _this_callbacks_onRemoteStream === void 0 ? void 0 : _this_callbacks_onRemoteStream.call(_this_callbacks, this.remoteStream, this.remoteUserId);\n        };\n        // Handle ICE candidates\n        this.peerConnection.onicecandidate = (event)=>{\n            if (event.candidate) {\n                console.log(\"\\uD83E\\uDDCA Sending ICE candidate\");\n                _socket__WEBPACK_IMPORTED_MODULE_0__.socketService.sendIceCandidate({\n                    candidate: event.candidate.toJSON(),\n                    to: this.remoteUserId\n                });\n            }\n        };\n        // Handle connection state changes\n        this.peerConnection.onconnectionstatechange = ()=>{\n            var _this_peerConnection, _this_callbacks_onConnectionStateChange, _this_callbacks;\n            const state = (_this_peerConnection = this.peerConnection) === null || _this_peerConnection === void 0 ? void 0 : _this_peerConnection.connectionState;\n            console.log(\"\\uD83D\\uDD04 Connection state:\", state);\n            (_this_callbacks_onConnectionStateChange = (_this_callbacks = this.callbacks).onConnectionStateChange) === null || _this_callbacks_onConnectionStateChange === void 0 ? void 0 : _this_callbacks_onConnectionStateChange.call(_this_callbacks, state);\n            if (state === \"failed\" || state === \"disconnected\" || state === \"closed\") {\n                console.log(\"\\uD83D\\uDCF4 Connection ended with state:\", state);\n            }\n        };\n        // Handle ICE connection state changes\n        this.peerConnection.oniceconnectionstatechange = ()=>{\n            var _this_peerConnection, _this_callbacks_onIceConnectionStateChange, _this_callbacks;\n            const state = (_this_peerConnection = this.peerConnection) === null || _this_peerConnection === void 0 ? void 0 : _this_peerConnection.iceConnectionState;\n            console.log(\"\\uD83E\\uDDCA ICE connection state:\", state);\n            (_this_callbacks_onIceConnectionStateChange = (_this_callbacks = this.callbacks).onIceConnectionStateChange) === null || _this_callbacks_onIceConnectionStateChange === void 0 ? void 0 : _this_callbacks_onIceConnectionStateChange.call(_this_callbacks, state);\n        };\n        // Handle ICE gathering state changes\n        this.peerConnection.onicegatheringstatechange = ()=>{\n            var _this_peerConnection;\n            console.log(\"\\uD83E\\uDDCA ICE gathering state:\", (_this_peerConnection = this.peerConnection) === null || _this_peerConnection === void 0 ? void 0 : _this_peerConnection.iceGatheringState);\n        };\n        // Process any pending ICE candidates\n        if (this.pendingIceCandidates.length > 0) {\n            console.log(\"\\uD83D\\uDCE6 Processing \".concat(this.pendingIceCandidates.length, \" pending ICE candidates\"));\n            for (const candidate of this.pendingIceCandidates){\n                await this.addIceCandidate(candidate);\n            }\n            this.pendingIceCandidates = [];\n        }\n        return this.peerConnection;\n    }\n    async initiateCall(remoteUserId, callId, type) {\n        console.log(\"\\uD83D\\uDCDE Initiating \".concat(type, \" call to \").concat(remoteUserId));\n        this.isInitiator = true;\n        this.remoteUserId = remoteUserId;\n        this.callId = callId;\n        this.callType = type;\n        try {\n            // Initialize media first\n            await this.initializeMedia(type);\n            // Create peer connection\n            await this.createPeerConnection();\n            // Create and send offer\n            const offer = await this.peerConnection.createOffer({\n                offerToReceiveAudio: true,\n                offerToReceiveVideo: type === \"video\"\n            });\n            console.log(\"\\uD83D\\uDCE4 Created offer:\", offer.type);\n            await this.peerConnection.setLocalDescription(offer);\n            // Send call signal to remote user\n            _socket__WEBPACK_IMPORTED_MODULE_0__.socketService.callUser({\n                userToCall: remoteUserId,\n                signalData: offer,\n                callType: type,\n                callId: callId\n            });\n            console.log(\"\\uD83D\\uDCE4 Sent call signal to:\", remoteUserId);\n        } catch (error) {\n            var _this_callbacks_onError, _this_callbacks;\n            console.error(\"❌ Error initiating call:\", error);\n            (_this_callbacks_onError = (_this_callbacks = this.callbacks).onError) === null || _this_callbacks_onError === void 0 ? void 0 : _this_callbacks_onError.call(_this_callbacks, error);\n            throw error;\n        }\n    }\n    async acceptCall(remoteUserId, callId, type, offer) {\n        console.log(\"\\uD83D\\uDCDE Accepting \".concat(type, \" call from \").concat(remoteUserId));\n        this.isInitiator = false;\n        this.remoteUserId = remoteUserId;\n        this.callId = callId;\n        this.callType = type;\n        try {\n            // Initialize media first\n            await this.initializeMedia(type);\n            // Create peer connection\n            await this.createPeerConnection();\n            // Set remote description (the offer)\n            console.log(\"\\uD83D\\uDCE5 Setting remote description (offer)\");\n            await this.peerConnection.setRemoteDescription(new RTCSessionDescription(offer));\n            // Create and send answer\n            const answer = await this.peerConnection.createAnswer();\n            console.log(\"\\uD83D\\uDCE4 Created answer:\", answer.type);\n            await this.peerConnection.setLocalDescription(answer);\n            // Send answer back to caller\n            _socket__WEBPACK_IMPORTED_MODULE_0__.socketService.answerCall({\n                signal: answer,\n                to: remoteUserId,\n                callId: callId\n            });\n            console.log(\"\\uD83D\\uDCE4 Sent answer to:\", remoteUserId);\n        } catch (error) {\n            var _this_callbacks_onError, _this_callbacks;\n            console.error(\"❌ Error accepting call:\", error);\n            (_this_callbacks_onError = (_this_callbacks = this.callbacks).onError) === null || _this_callbacks_onError === void 0 ? void 0 : _this_callbacks_onError.call(_this_callbacks, error);\n            throw error;\n        }\n    }\n    async handleAnswer(answer) {\n        console.log(\"\\uD83D\\uDCE5 Handling answer\");\n        if (!this.peerConnection) {\n            console.error(\"❌ No peer connection exists\");\n            return;\n        }\n        try {\n            await this.peerConnection.setRemoteDescription(new RTCSessionDescription(answer));\n            console.log(\"✅ Set remote description (answer)\");\n        } catch (error) {\n            var _this_callbacks_onError, _this_callbacks;\n            console.error(\"❌ Error handling answer:\", error);\n            (_this_callbacks_onError = (_this_callbacks = this.callbacks).onError) === null || _this_callbacks_onError === void 0 ? void 0 : _this_callbacks_onError.call(_this_callbacks, error);\n        }\n    }\n    async addIceCandidate(candidate) {\n        if (!this.peerConnection || !this.peerConnection.remoteDescription) {\n            console.log(\"\\uD83D\\uDCE6 Queuing ICE candidate (no remote description yet)\");\n            this.pendingIceCandidates.push(candidate);\n            return;\n        }\n        try {\n            await this.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\n            console.log(\"✅ Added ICE candidate\");\n        } catch (error) {\n            console.error(\"❌ Error adding ICE candidate:\", error);\n        }\n    }\n    async startScreenShare() {\n        try {\n            console.log(\"\\uD83D\\uDDA5️ Starting screen share\");\n            this.screenStream = await navigator.mediaDevices.getDisplayMedia({\n                video: {\n                    cursor: \"always\",\n                    displaySurface: \"monitor\"\n                },\n                audio: {\n                    echoCancellation: true,\n                    noiseSuppression: true\n                }\n            });\n            const videoTrack = this.screenStream.getVideoTracks()[0];\n            // Store original video track\n            if (this.localStream) {\n                this.originalVideoTrack = this.localStream.getVideoTracks()[0] || null;\n            }\n            // Handle when user stops sharing via browser UI\n            videoTrack.onended = ()=>{\n                console.log(\"\\uD83D\\uDDA5️ Screen share ended by user\");\n                this.stopScreenShare();\n            };\n            // Replace video track in peer connection\n            if (this.peerConnection && this.localStream) {\n                const sender = this.peerConnection.getSenders().find((s)=>{\n                    var _s_track;\n                    return ((_s_track = s.track) === null || _s_track === void 0 ? void 0 : _s_track.kind) === \"video\";\n                });\n                if (sender) {\n                    await sender.replaceTrack(videoTrack);\n                    console.log(\"✅ Replaced video track with screen share\");\n                }\n            }\n            this.isScreenSharing = true;\n            return this.screenStream;\n        } catch (error) {\n            var _this_callbacks_onError, _this_callbacks;\n            console.error(\"❌ Error starting screen share:\", error);\n            (_this_callbacks_onError = (_this_callbacks = this.callbacks).onError) === null || _this_callbacks_onError === void 0 ? void 0 : _this_callbacks_onError.call(_this_callbacks, error);\n            return null;\n        }\n    }\n    async stopScreenShare() {\n        console.log(\"\\uD83D\\uDDA5️ Stopping screen share\");\n        try {\n            // Stop screen stream tracks\n            if (this.screenStream) {\n                this.screenStream.getTracks().forEach((track)=>track.stop());\n                this.screenStream = null;\n            }\n            // Restore original video track\n            if (this.peerConnection && this.originalVideoTrack) {\n                const sender = this.peerConnection.getSenders().find((s)=>{\n                    var _s_track;\n                    return ((_s_track = s.track) === null || _s_track === void 0 ? void 0 : _s_track.kind) === \"video\";\n                });\n                if (sender) {\n                    await sender.replaceTrack(this.originalVideoTrack);\n                    console.log(\"✅ Restored original video track\");\n                }\n            } else if (this.peerConnection && this.callType === \"video\") {\n                // Re-acquire camera if original track is gone\n                try {\n                    const newStream = await navigator.mediaDevices.getUserMedia({\n                        video: true\n                    });\n                    const newVideoTrack = newStream.getVideoTracks()[0];\n                    const sender = this.peerConnection.getSenders().find((s)=>{\n                        var _s_track;\n                        return ((_s_track = s.track) === null || _s_track === void 0 ? void 0 : _s_track.kind) === \"video\";\n                    });\n                    if (sender) {\n                        await sender.replaceTrack(newVideoTrack);\n                        console.log(\"✅ Acquired new video track\");\n                    }\n                    // Update local stream\n                    if (this.localStream) {\n                        var _this_callbacks_onLocalStream, _this_callbacks;\n                        const oldVideoTrack = this.localStream.getVideoTracks()[0];\n                        if (oldVideoTrack) {\n                            this.localStream.removeTrack(oldVideoTrack);\n                        }\n                        this.localStream.addTrack(newVideoTrack);\n                        (_this_callbacks_onLocalStream = (_this_callbacks = this.callbacks).onLocalStream) === null || _this_callbacks_onLocalStream === void 0 ? void 0 : _this_callbacks_onLocalStream.call(_this_callbacks, this.localStream);\n                    }\n                } catch (error) {\n                    console.error(\"❌ Error re-acquiring camera:\", error);\n                }\n            }\n            this.isScreenSharing = false;\n            this.originalVideoTrack = null;\n        } catch (error) {\n            console.error(\"❌ Error stopping screen share:\", error);\n        }\n    }\n    toggleMute() {\n        if (this.localStream) {\n            const audioTrack = this.localStream.getAudioTracks()[0];\n            if (audioTrack) {\n                audioTrack.enabled = !audioTrack.enabled;\n                console.log(\"\\uD83C\\uDFA4 Mic \".concat(audioTrack.enabled ? \"unmuted\" : \"muted\"));\n                return !audioTrack.enabled; // Return isMuted state\n            }\n        }\n        return false;\n    }\n    toggleVideo() {\n        if (this.localStream && !this.isScreenSharing) {\n            const videoTrack = this.localStream.getVideoTracks()[0];\n            if (videoTrack) {\n                videoTrack.enabled = !videoTrack.enabled;\n                console.log(\"\\uD83D\\uDCF9 Video \".concat(videoTrack.enabled ? \"enabled\" : \"disabled\"));\n                return videoTrack.enabled;\n            }\n        }\n        return true;\n    }\n    getIsScreenSharing() {\n        return this.isScreenSharing;\n    }\n    stopLocalStream() {\n        if (this.localStream) {\n            this.localStream.getTracks().forEach((track)=>{\n                track.stop();\n                console.log(\"⏹️ Stopped \".concat(track.kind, \" track\"));\n            });\n            this.localStream = null;\n        }\n    }\n    endCall() {\n        var _this_callbacks_onCallEnded, _this_callbacks;\n        console.log(\"\\uD83D\\uDCF4 Ending call\");\n        // Stop screen share if active\n        if (this.isScreenSharing) {\n            this.stopScreenShare();\n        }\n        // Stop local stream\n        this.stopLocalStream();\n        // Stop remote stream\n        if (this.remoteStream) {\n            this.remoteStream.getTracks().forEach((track)=>track.stop());\n            this.remoteStream = null;\n        }\n        // Close peer connection\n        if (this.peerConnection) {\n            this.peerConnection.close();\n            this.peerConnection = null;\n        }\n        // Reset state\n        this.pendingIceCandidates = [];\n        this.isInitiator = false;\n        this.remoteUserId = \"\";\n        this.callId = \"\";\n        this.originalVideoTrack = null;\n        this.isScreenSharing = false;\n        (_this_callbacks_onCallEnded = (_this_callbacks = this.callbacks).onCallEnded) === null || _this_callbacks_onCallEnded === void 0 ? void 0 : _this_callbacks_onCallEnded.call(_this_callbacks);\n    }\n    getLocalStream() {\n        return this.localStream;\n    }\n    getRemoteStream() {\n        return this.remoteStream;\n    }\n    getPeerConnection() {\n        return this.peerConnection;\n    }\n    getCallId() {\n        return this.callId;\n    }\n    getRemoteUserId() {\n        return this.remoteUserId;\n    }\n    constructor(){\n        this.peerConnection = null;\n        this.localStream = null;\n        this.remoteStream = null;\n        this.screenStream = null;\n        this.callbacks = {};\n        this.pendingIceCandidates = [];\n        this.isInitiator = false;\n        this.remoteUserId = \"\";\n        this.callId = \"\";\n        this.callType = \"audio\";\n        this.isScreenSharing = false;\n        this.originalVideoTrack = null;\n    }\n}\n// Export singleton instance\nconst webRTCService = new WebRTCService();\n/* harmony default export */ __webpack_exports__[\"default\"] = (webRTCService);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFZO0lBQzFCOzthQTFjUVgsaUJBQTJDO2FBQzNDWixjQUFrQzthQUNsQ21CLGVBQW1DO2FBQ25DNkMsZUFBbUM7YUFDbkNyRixZQUFzQyxDQUFDO2FBQ3ZDMkQsdUJBQThDLEVBQUU7YUFDaERLLGNBQXVCO2FBQ3ZCcEIsZUFBdUI7YUFDdkJtQixTQUFpQjthQUNqQnBDLFdBQXFCO2FBQ3JCd0Usa0JBQTJCO2FBQzNCUixxQkFBOEM7O0FBZ2N4RDtBQUVBLDRCQUE0QjtBQUNyQixNQUFNMkIsZ0JBQWdCLElBQUl4SCxnQkFBZ0I7QUFDakQsK0RBQWV3SCxhQUFhQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvd2VicnRjLnRzPzMxZDUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xyXG5cclxuaW1wb3J0IHsgc29ja2V0U2VydmljZSB9IGZyb20gJy4vc29ja2V0JztcclxuXHJcbi8vIElDRSBzZXJ2ZXJzIGNvbmZpZ3VyYXRpb24gZm9yIFNUVU4vVFVSTlxyXG5jb25zdCBJQ0VfU0VSVkVSUzogUlRDQ29uZmlndXJhdGlvbiA9IHtcclxuICBpY2VTZXJ2ZXJzOiBbXHJcbiAgICB7IHVybHM6ICdzdHVuOnN0dW4ubC5nb29nbGUuY29tOjE5MzAyJyB9LFxyXG4gICAgeyB1cmxzOiAnc3R1bjpzdHVuMS5sLmdvb2dsZS5jb206MTkzMDInIH0sXHJcbiAgICB7IHVybHM6ICdzdHVuOnN0dW4yLmwuZ29vZ2xlLmNvbToxOTMwMicgfSxcclxuICAgIHsgdXJsczogJ3N0dW46c3R1bjMubC5nb29nbGUuY29tOjE5MzAyJyB9LFxyXG4gICAgeyB1cmxzOiAnc3R1bjpzdHVuNC5sLmdvb2dsZS5jb206MTkzMDInIH0sXHJcbiAgXSxcclxuICBpY2VDYW5kaWRhdGVQb29sU2l6ZTogMTAsXHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBDYWxsVHlwZSA9ICdhdWRpbycgfCAndmlkZW8nO1xyXG5cclxuaW50ZXJmYWNlIFdlYlJUQ0NhbGxiYWNrcyB7XHJcbiAgb25Mb2NhbFN0cmVhbTogKHN0cmVhbTogTWVkaWFTdHJlYW0pID0+IHZvaWQ7XHJcbiAgb25SZW1vdGVTdHJlYW06IChzdHJlYW06IE1lZGlhU3RyZWFtLCBwZWVySWQ6IHN0cmluZykgPT4gdm9pZDtcclxuICBvbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZTogKHN0YXRlOiBSVENQZWVyQ29ubmVjdGlvblN0YXRlKSA9PiB2b2lkO1xyXG4gIG9uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlOiAoc3RhdGU6IFJUQ0ljZUNvbm5lY3Rpb25TdGF0ZSkgPT4gdm9pZDtcclxuICBvbkNhbGxFbmRlZDogKCkgPT4gdm9pZDtcclxuICBvbkVycm9yOiAoZXJyb3I6IEVycm9yKSA9PiB2b2lkO1xyXG59XHJcblxyXG4vLyBDaGVjayBpZiBXZWJSVEMgaXMgc3VwcG9ydGVkIGFuZCB3ZSdyZSBpbiBhIHNlY3VyZSBjb250ZXh0XHJcbmZ1bmN0aW9uIGNoZWNrV2ViUlRDU3VwcG9ydCgpOiB7IHN1cHBvcnRlZDogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmcgfSB7XHJcbiAgLy8gQ2hlY2sgaWYgd2UncmUgaW4gYSBicm93c2VyIGVudmlyb25tZW50XHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICByZXR1cm4geyBzdXBwb3J0ZWQ6IGZhbHNlLCBlcnJvcjogJ05vdCBpbiBicm93c2VyIGVudmlyb25tZW50JyB9O1xyXG4gIH1cclxuXHJcbiAgLy8gQ2hlY2sgZm9yIHNlY3VyZSBjb250ZXh0IChIVFRQUyBvciBsb2NhbGhvc3QpXHJcbiAgaWYgKCF3aW5kb3cuaXNTZWN1cmVDb250ZXh0KSB7XHJcbiAgICBjb25zdCBpc0xvY2FsaG9zdCA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSA9PT0gJ2xvY2FsaG9zdCcgfHwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSA9PT0gJzEyNy4wLjAuMSc7XHJcbiAgICBpZiAoIWlzTG9jYWxob3N0KSB7XHJcbiAgICAgIHJldHVybiB7IFxyXG4gICAgICAgIHN1cHBvcnRlZDogZmFsc2UsIFxyXG4gICAgICAgIGVycm9yOiAnV2ViUlRDIHJlcXVpcmVzIEhUVFBTLiBQbGVhc2UgYWNjZXNzIHZpYSBsb2NhbGhvc3Q6MzAwNCBvciB1c2UgSFRUUFMuJyBcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIENoZWNrIGZvciBtZWRpYURldmljZXMgQVBJXHJcbiAgaWYgKCFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzIHx8ICFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSkge1xyXG4gICAgcmV0dXJuIHsgXHJcbiAgICAgIHN1cHBvcnRlZDogZmFsc2UsIFxyXG4gICAgICBlcnJvcjogJ1lvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFdlYlJUQy4gUGxlYXNlIHVzZSBhIG1vZGVybiBicm93c2VyIGxpa2UgQ2hyb21lLCBGaXJlZm94LCBvciBFZGdlLicgXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gQ2hlY2sgZm9yIFJUQ1BlZXJDb25uZWN0aW9uXHJcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcclxuICAgIHJldHVybiB7IFxyXG4gICAgICBzdXBwb3J0ZWQ6IGZhbHNlLCBcclxuICAgICAgZXJyb3I6ICdXZWJSVEMgaXMgbm90IGZ1bGx5IHN1cHBvcnRlZCBpbiB5b3VyIGJyb3dzZXIuJyBcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICByZXR1cm4geyBzdXBwb3J0ZWQ6IHRydWUgfTtcclxufVxyXG5cclxuY2xhc3MgV2ViUlRDU2VydmljZSB7XHJcbiAgcHJpdmF0ZSBwZWVyQ29ubmVjdGlvbjogUlRDUGVlckNvbm5lY3Rpb24gfCBudWxsID0gbnVsbDtcclxuICBwcml2YXRlIGxvY2FsU3RyZWFtOiBNZWRpYVN0cmVhbSB8IG51bGwgPSBudWxsO1xyXG4gIHByaXZhdGUgcmVtb3RlU3RyZWFtOiBNZWRpYVN0cmVhbSB8IG51bGwgPSBudWxsO1xyXG4gIHByaXZhdGUgc2NyZWVuU3RyZWFtOiBNZWRpYVN0cmVhbSB8IG51bGwgPSBudWxsO1xyXG4gIHByaXZhdGUgY2FsbGJhY2tzOiBQYXJ0aWFsPFdlYlJUQ0NhbGxiYWNrcz4gPSB7fTtcclxuICBwcml2YXRlIHBlbmRpbmdJY2VDYW5kaWRhdGVzOiBSVENJY2VDYW5kaWRhdGVJbml0W10gPSBbXTtcclxuICBwcml2YXRlIGlzSW5pdGlhdG9yOiBib29sZWFuID0gZmFsc2U7XHJcbiAgcHJpdmF0ZSByZW1vdGVVc2VySWQ6IHN0cmluZyA9ICcnO1xyXG4gIHByaXZhdGUgY2FsbElkOiBzdHJpbmcgPSAnJztcclxuICBwcml2YXRlIGNhbGxUeXBlOiBDYWxsVHlwZSA9ICdhdWRpbyc7XHJcbiAgcHJpdmF0ZSBpc1NjcmVlblNoYXJpbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuICBwcml2YXRlIG9yaWdpbmFsVmlkZW9UcmFjazogTWVkaWFTdHJlYW1UcmFjayB8IG51bGwgPSBudWxsO1xyXG5cclxuICBzZXRDYWxsYmFja3MoY2FsbGJhY2tzOiBQYXJ0aWFsPFdlYlJUQ0NhbGxiYWNrcz4pIHtcclxuICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgaW5pdGlhbGl6ZU1lZGlhKHR5cGU6IENhbGxUeXBlKTogUHJvbWlzZTxNZWRpYVN0cmVhbT4ge1xyXG4gICAgLy8gQ2hlY2sgV2ViUlRDIHN1cHBvcnQgZmlyc3RcclxuICAgIGNvbnN0IHN1cHBvcnQgPSBjaGVja1dlYlJUQ1N1cHBvcnQoKTtcclxuICAgIGlmICghc3VwcG9ydC5zdXBwb3J0ZWQpIHtcclxuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3Ioc3VwcG9ydC5lcnJvciB8fCAnV2ViUlRDIG5vdCBzdXBwb3J0ZWQnKTtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIFdlYlJUQyBub3Qgc3VwcG9ydGVkOicsIHN1cHBvcnQuZXJyb3IpO1xyXG4gICAgICB0aGlzLmNhbGxiYWNrcy5vbkVycm9yPy4oZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBTdG9wIGFueSBleGlzdGluZyBzdHJlYW1zIGZpcnN0XHJcbiAgICAgIHRoaXMuc3RvcExvY2FsU3RyZWFtKCk7XHJcblxyXG4gICAgICBjb25zdCBjb25zdHJhaW50czogTWVkaWFTdHJlYW1Db25zdHJhaW50cyA9IHtcclxuICAgICAgICBhdWRpbzoge1xyXG4gICAgICAgICAgZWNob0NhbmNlbGxhdGlvbjogdHJ1ZSxcclxuICAgICAgICAgIG5vaXNlU3VwcHJlc3Npb246IHRydWUsXHJcbiAgICAgICAgICBhdXRvR2FpbkNvbnRyb2w6IHRydWUsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB2aWRlbzogdHlwZSA9PT0gJ3ZpZGVvJyA/IHtcclxuICAgICAgICAgIHdpZHRoOiB7IGlkZWFsOiAxMjgwLCBtYXg6IDE5MjAgfSxcclxuICAgICAgICAgIGhlaWdodDogeyBpZGVhbDogNzIwLCBtYXg6IDEwODAgfSxcclxuICAgICAgICAgIGZyYW1lUmF0ZTogeyBpZGVhbDogMzAsIG1heDogNjAgfSxcclxuICAgICAgICAgIGZhY2luZ01vZGU6ICd1c2VyJyxcclxuICAgICAgICB9IDogZmFsc2UsXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zb2xlLmxvZygn8J+TuSBSZXF1ZXN0aW5nIG1lZGlhIHdpdGggY29uc3RyYWludHM6JywgY29uc3RyYWludHMpO1xyXG4gICAgICB0aGlzLmxvY2FsU3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xyXG4gICAgICBjb25zb2xlLmxvZygn4pyFIEdvdCBsb2NhbCBzdHJlYW06JywgdGhpcy5sb2NhbFN0cmVhbS5nZXRUcmFja3MoKS5tYXAodCA9PiBgJHt0LmtpbmR9OiAke3QubGFiZWx9YCkpO1xyXG4gICAgICBcclxuICAgICAgdGhpcy5jYWxsVHlwZSA9IHR5cGU7XHJcbiAgICAgIHRoaXMuY2FsbGJhY2tzLm9uTG9jYWxTdHJlYW0/Lih0aGlzLmxvY2FsU3RyZWFtKTtcclxuICAgICAgXHJcbiAgICAgIHJldHVybiB0aGlzLmxvY2FsU3RyZWFtO1xyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgYWNjZXNzaW5nIG1lZGlhIGRldmljZXM6JywgZXJyb3IpO1xyXG4gICAgICBcclxuICAgICAgLy8gUHJvdmlkZSB1c2VyLWZyaWVuZGx5IGVycm9yIG1lc3NhZ2VzXHJcbiAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSAnRmFpbGVkIHRvIGFjY2VzcyBjYW1lcmEvbWljcm9waG9uZSc7XHJcbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnTm90QWxsb3dlZEVycm9yJyB8fCBlcnJvci5uYW1lID09PSAnUGVybWlzc2lvbkRlbmllZEVycm9yJykge1xyXG4gICAgICAgIGVycm9yTWVzc2FnZSA9ICdDYW1lcmEvbWljcm9waG9uZSBwZXJtaXNzaW9uIGRlbmllZC4gUGxlYXNlIGFsbG93IGFjY2VzcyBpbiB5b3VyIGJyb3dzZXIgc2V0dGluZ3MuJztcclxuICAgICAgfSBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnTm90Rm91bmRFcnJvcicgfHwgZXJyb3IubmFtZSA9PT0gJ0RldmljZXNOb3RGb3VuZEVycm9yJykge1xyXG4gICAgICAgIGVycm9yTWVzc2FnZSA9ICdObyBjYW1lcmEgb3IgbWljcm9waG9uZSBmb3VuZC4gUGxlYXNlIGNvbm5lY3QgYSBkZXZpY2UgYW5kIHRyeSBhZ2Fpbi4nO1xyXG4gICAgICB9IGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RSZWFkYWJsZUVycm9yJyB8fCBlcnJvci5uYW1lID09PSAnVHJhY2tTdGFydEVycm9yJykge1xyXG4gICAgICAgIGVycm9yTWVzc2FnZSA9ICdDYW1lcmEvbWljcm9waG9uZSBpcyBhbHJlYWR5IGluIHVzZSBieSBhbm90aGVyIGFwcGxpY2F0aW9uLic7XHJcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ092ZXJjb25zdHJhaW5lZEVycm9yJykge1xyXG4gICAgICAgIGVycm9yTWVzc2FnZSA9ICdDYW1lcmEgZG9lcyBub3Qgc3VwcG9ydCB0aGUgcmVxdWVzdGVkIHZpZGVvIHF1YWxpdHkuJztcclxuICAgICAgfSBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnVHlwZUVycm9yJykge1xyXG4gICAgICAgIGVycm9yTWVzc2FnZSA9ICdXZWJSVEMgcmVxdWlyZXMgSFRUUFMuIFBsZWFzZSBhY2Nlc3MgdmlhIGxvY2FsaG9zdDozMDA0JztcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc3QgY3VzdG9tRXJyb3IgPSBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcclxuICAgICAgdGhpcy5jYWxsYmFja3Mub25FcnJvcj8uKGN1c3RvbUVycm9yKTtcclxuICAgICAgdGhyb3cgY3VzdG9tRXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBjcmVhdGVQZWVyQ29ubmVjdGlvbigpOiBQcm9taXNlPFJUQ1BlZXJDb25uZWN0aW9uPiB7XHJcbiAgICBpZiAodGhpcy5wZWVyQ29ubmVjdGlvbikge1xyXG4gICAgICBjb25zb2xlLmxvZygn4pm777iPIENsb3NpbmcgZXhpc3RpbmcgcGVlciBjb25uZWN0aW9uJyk7XHJcbiAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24uY2xvc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZygn8J+UlyBDcmVhdGluZyBuZXcgUlRDUGVlckNvbm5lY3Rpb24nKTtcclxuICAgIHRoaXMucGVlckNvbm5lY3Rpb24gPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oSUNFX1NFUlZFUlMpO1xyXG5cclxuICAgIC8vIEFkZCBsb2NhbCB0cmFja3MgdG8gcGVlciBjb25uZWN0aW9uXHJcbiAgICBpZiAodGhpcy5sb2NhbFN0cmVhbSkge1xyXG4gICAgICB0aGlzLmxvY2FsU3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDinpUgQWRkaW5nICR7dHJhY2sua2luZH0gdHJhY2sgdG8gcGVlciBjb25uZWN0aW9uYCk7XHJcbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbiEuYWRkVHJhY2sodHJhY2ssIHRoaXMubG9jYWxTdHJlYW0hKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGFuZGxlIGluY29taW5nIHRyYWNrc1xyXG4gICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5vbnRyYWNrID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OlIFJlY2VpdmVkIHJlbW90ZSB0cmFjazonLCBldmVudC50cmFjay5raW5kKTtcclxuICAgICAgXHJcbiAgICAgIGlmICghdGhpcy5yZW1vdGVTdHJlYW0pIHtcclxuICAgICAgICB0aGlzLnJlbW90ZVN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBldmVudC5zdHJlYW1zWzBdLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDinpUgQWRkaW5nIHJlbW90ZSAke3RyYWNrLmtpbmR9IHRyYWNrYCk7XHJcbiAgICAgICAgdGhpcy5yZW1vdGVTdHJlYW0hLmFkZFRyYWNrKHRyYWNrKTtcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICB0aGlzLmNhbGxiYWNrcy5vblJlbW90ZVN0cmVhbT8uKHRoaXMucmVtb3RlU3RyZWFtLCB0aGlzLnJlbW90ZVVzZXJJZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEhhbmRsZSBJQ0UgY2FuZGlkYXRlc1xyXG4gICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5vbmljZWNhbmRpZGF0ZSA9IChldmVudCkgPT4ge1xyXG4gICAgICBpZiAoZXZlbnQuY2FuZGlkYXRlKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfp4ogU2VuZGluZyBJQ0UgY2FuZGlkYXRlJyk7XHJcbiAgICAgICAgc29ja2V0U2VydmljZS5zZW5kSWNlQ2FuZGlkYXRlKHtcclxuICAgICAgICAgIGNhbmRpZGF0ZTogZXZlbnQuY2FuZGlkYXRlLnRvSlNPTigpLFxyXG4gICAgICAgICAgdG86IHRoaXMucmVtb3RlVXNlcklkLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEhhbmRsZSBjb25uZWN0aW9uIHN0YXRlIGNoYW5nZXNcclxuICAgIHRoaXMucGVlckNvbm5lY3Rpb24ub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5wZWVyQ29ubmVjdGlvbj8uY29ubmVjdGlvblN0YXRlO1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+UhCBDb25uZWN0aW9uIHN0YXRlOicsIHN0YXRlKTtcclxuICAgICAgdGhpcy5jYWxsYmFja3Mub25Db25uZWN0aW9uU3RhdGVDaGFuZ2U/LihzdGF0ZSBhcyBSVENQZWVyQ29ubmVjdGlvblN0YXRlKTtcclxuICAgICAgXHJcbiAgICAgIGlmIChzdGF0ZSA9PT0gJ2ZhaWxlZCcgfHwgc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnIHx8IHN0YXRlID09PSAnY2xvc2VkJykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5O0IENvbm5lY3Rpb24gZW5kZWQgd2l0aCBzdGF0ZTonLCBzdGF0ZSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gSGFuZGxlIElDRSBjb25uZWN0aW9uIHN0YXRlIGNoYW5nZXNcclxuICAgIHRoaXMucGVlckNvbm5lY3Rpb24ub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5wZWVyQ29ubmVjdGlvbj8uaWNlQ29ubmVjdGlvblN0YXRlO1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+niiBJQ0UgY29ubmVjdGlvbiBzdGF0ZTonLCBzdGF0ZSk7XHJcbiAgICAgIHRoaXMuY2FsbGJhY2tzLm9uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlPy4oc3RhdGUgYXMgUlRDSWNlQ29ubmVjdGlvblN0YXRlKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gSGFuZGxlIElDRSBnYXRoZXJpbmcgc3RhdGUgY2hhbmdlc1xyXG4gICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5vbmljZWdhdGhlcmluZ3N0YXRlY2hhbmdlID0gKCkgPT4ge1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+niiBJQ0UgZ2F0aGVyaW5nIHN0YXRlOicsIHRoaXMucGVlckNvbm5lY3Rpb24/LmljZUdhdGhlcmluZ1N0YXRlKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gUHJvY2VzcyBhbnkgcGVuZGluZyBJQ0UgY2FuZGlkYXRlc1xyXG4gICAgaWYgKHRoaXMucGVuZGluZ0ljZUNhbmRpZGF0ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+TpiBQcm9jZXNzaW5nICR7dGhpcy5wZW5kaW5nSWNlQ2FuZGlkYXRlcy5sZW5ndGh9IHBlbmRpbmcgSUNFIGNhbmRpZGF0ZXNgKTtcclxuICAgICAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgdGhpcy5wZW5kaW5nSWNlQ2FuZGlkYXRlcykge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5wZW5kaW5nSWNlQ2FuZGlkYXRlcyA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLnBlZXJDb25uZWN0aW9uO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgaW5pdGlhdGVDYWxsKHJlbW90ZVVzZXJJZDogc3RyaW5nLCBjYWxsSWQ6IHN0cmluZywgdHlwZTogQ2FsbFR5cGUpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGNvbnNvbGUubG9nKGDwn5OeIEluaXRpYXRpbmcgJHt0eXBlfSBjYWxsIHRvICR7cmVtb3RlVXNlcklkfWApO1xyXG4gICAgXHJcbiAgICB0aGlzLmlzSW5pdGlhdG9yID0gdHJ1ZTtcclxuICAgIHRoaXMucmVtb3RlVXNlcklkID0gcmVtb3RlVXNlcklkO1xyXG4gICAgdGhpcy5jYWxsSWQgPSBjYWxsSWQ7XHJcbiAgICB0aGlzLmNhbGxUeXBlID0gdHlwZTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBJbml0aWFsaXplIG1lZGlhIGZpcnN0XHJcbiAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZU1lZGlhKHR5cGUpO1xyXG4gICAgICBcclxuICAgICAgLy8gQ3JlYXRlIHBlZXIgY29ubmVjdGlvblxyXG4gICAgICBhd2FpdCB0aGlzLmNyZWF0ZVBlZXJDb25uZWN0aW9uKCk7XHJcblxyXG4gICAgICAvLyBDcmVhdGUgYW5kIHNlbmQgb2ZmZXJcclxuICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLnBlZXJDb25uZWN0aW9uIS5jcmVhdGVPZmZlcih7XHJcbiAgICAgICAgb2ZmZXJUb1JlY2VpdmVBdWRpbzogdHJ1ZSxcclxuICAgICAgICBvZmZlclRvUmVjZWl2ZVZpZGVvOiB0eXBlID09PSAndmlkZW8nLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OkIENyZWF0ZWQgb2ZmZXI6Jywgb2ZmZXIudHlwZSk7XHJcbiAgICAgIGF3YWl0IHRoaXMucGVlckNvbm5lY3Rpb24hLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xyXG5cclxuICAgICAgLy8gU2VuZCBjYWxsIHNpZ25hbCB0byByZW1vdGUgdXNlclxyXG4gICAgICBzb2NrZXRTZXJ2aWNlLmNhbGxVc2VyKHtcclxuICAgICAgICB1c2VyVG9DYWxsOiByZW1vdGVVc2VySWQsXHJcbiAgICAgICAgc2lnbmFsRGF0YTogb2ZmZXIsXHJcbiAgICAgICAgY2FsbFR5cGU6IHR5cGUsXHJcbiAgICAgICAgY2FsbElkOiBjYWxsSWQsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY29uc29sZS5sb2coJ/Cfk6QgU2VudCBjYWxsIHNpZ25hbCB0bzonLCByZW1vdGVVc2VySWQpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGluaXRpYXRpbmcgY2FsbDonLCBlcnJvcik7XHJcbiAgICAgIHRoaXMuY2FsbGJhY2tzLm9uRXJyb3I/LihlcnJvciBhcyBFcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgYWNjZXB0Q2FsbChcclxuICAgIHJlbW90ZVVzZXJJZDogc3RyaW5nLFxyXG4gICAgY2FsbElkOiBzdHJpbmcsXHJcbiAgICB0eXBlOiBDYWxsVHlwZSxcclxuICAgIG9mZmVyOiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0XHJcbiAgKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zb2xlLmxvZyhg8J+TniBBY2NlcHRpbmcgJHt0eXBlfSBjYWxsIGZyb20gJHtyZW1vdGVVc2VySWR9YCk7XHJcbiAgICBcclxuICAgIHRoaXMuaXNJbml0aWF0b3IgPSBmYWxzZTtcclxuICAgIHRoaXMucmVtb3RlVXNlcklkID0gcmVtb3RlVXNlcklkO1xyXG4gICAgdGhpcy5jYWxsSWQgPSBjYWxsSWQ7XHJcbiAgICB0aGlzLmNhbGxUeXBlID0gdHlwZTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBJbml0aWFsaXplIG1lZGlhIGZpcnN0XHJcbiAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZU1lZGlhKHR5cGUpO1xyXG4gICAgICBcclxuICAgICAgLy8gQ3JlYXRlIHBlZXIgY29ubmVjdGlvblxyXG4gICAgICBhd2FpdCB0aGlzLmNyZWF0ZVBlZXJDb25uZWN0aW9uKCk7XHJcblxyXG4gICAgICAvLyBTZXQgcmVtb3RlIGRlc2NyaXB0aW9uICh0aGUgb2ZmZXIpXHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OlIFNldHRpbmcgcmVtb3RlIGRlc2NyaXB0aW9uIChvZmZlciknKTtcclxuICAgICAgYXdhaXQgdGhpcy5wZWVyQ29ubmVjdGlvbiEuc2V0UmVtb3RlRGVzY3JpcHRpb24obmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbihvZmZlcikpO1xyXG5cclxuICAgICAgLy8gQ3JlYXRlIGFuZCBzZW5kIGFuc3dlclxyXG4gICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLnBlZXJDb25uZWN0aW9uIS5jcmVhdGVBbnN3ZXIoKTtcclxuICAgICAgY29uc29sZS5sb2coJ/Cfk6QgQ3JlYXRlZCBhbnN3ZXI6JywgYW5zd2VyLnR5cGUpO1xyXG4gICAgICBcclxuICAgICAgYXdhaXQgdGhpcy5wZWVyQ29ubmVjdGlvbiEuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xyXG5cclxuICAgICAgLy8gU2VuZCBhbnN3ZXIgYmFjayB0byBjYWxsZXJcclxuICAgICAgc29ja2V0U2VydmljZS5hbnN3ZXJDYWxsKHtcclxuICAgICAgICBzaWduYWw6IGFuc3dlcixcclxuICAgICAgICB0bzogcmVtb3RlVXNlcklkLFxyXG4gICAgICAgIGNhbGxJZDogY2FsbElkLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OkIFNlbnQgYW5zd2VyIHRvOicsIHJlbW90ZVVzZXJJZCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgYWNjZXB0aW5nIGNhbGw6JywgZXJyb3IpO1xyXG4gICAgICB0aGlzLmNhbGxiYWNrcy5vbkVycm9yPy4oZXJyb3IgYXMgRXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGhhbmRsZUFuc3dlcihhbnN3ZXI6IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGNvbnNvbGUubG9nKCfwn5OlIEhhbmRsaW5nIGFuc3dlcicpO1xyXG4gICAgXHJcbiAgICBpZiAoIXRoaXMucGVlckNvbm5lY3Rpb24pIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIE5vIHBlZXIgY29ubmVjdGlvbiBleGlzdHMnKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IHRoaXMucGVlckNvbm5lY3Rpb24uc2V0UmVtb3RlRGVzY3JpcHRpb24obmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbihhbnN3ZXIpKTtcclxuICAgICAgY29uc29sZS5sb2coJ+KchSBTZXQgcmVtb3RlIGRlc2NyaXB0aW9uIChhbnN3ZXIpJyk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgaGFuZGxpbmcgYW5zd2VyOicsIGVycm9yKTtcclxuICAgICAgdGhpcy5jYWxsYmFja3Mub25FcnJvcj8uKGVycm9yIGFzIEVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGU6IFJUQ0ljZUNhbmRpZGF0ZUluaXQpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGlmICghdGhpcy5wZWVyQ29ubmVjdGlvbiB8fCAhdGhpcy5wZWVyQ29ubmVjdGlvbi5yZW1vdGVEZXNjcmlwdGlvbikge1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+TpiBRdWV1aW5nIElDRSBjYW5kaWRhdGUgKG5vIHJlbW90ZSBkZXNjcmlwdGlvbiB5ZXQpJyk7XHJcbiAgICAgIHRoaXMucGVuZGluZ0ljZUNhbmRpZGF0ZXMucHVzaChjYW5kaWRhdGUpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgdGhpcy5wZWVyQ29ubmVjdGlvbi5hZGRJY2VDYW5kaWRhdGUobmV3IFJUQ0ljZUNhbmRpZGF0ZShjYW5kaWRhdGUpKTtcclxuICAgICAgY29uc29sZS5sb2coJ+KchSBBZGRlZCBJQ0UgY2FuZGlkYXRlJyk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgYWRkaW5nIElDRSBjYW5kaWRhdGU6JywgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgc3RhcnRTY3JlZW5TaGFyZSgpOiBQcm9taXNlPE1lZGlhU3RyZWFtIHwgbnVsbD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ/CflqXvuI8gU3RhcnRpbmcgc2NyZWVuIHNoYXJlJyk7XHJcbiAgICAgIFxyXG4gICAgICB0aGlzLnNjcmVlblN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhKHtcclxuICAgICAgICB2aWRlbzoge1xyXG4gICAgICAgICAgY3Vyc29yOiAnYWx3YXlzJyxcclxuICAgICAgICAgIGRpc3BsYXlTdXJmYWNlOiAnbW9uaXRvcicsXHJcbiAgICAgICAgfSBhcyBhbnksXHJcbiAgICAgICAgYXVkaW86IHtcclxuICAgICAgICAgIGVjaG9DYW5jZWxsYXRpb246IHRydWUsXHJcbiAgICAgICAgICBub2lzZVN1cHByZXNzaW9uOiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY29uc3QgdmlkZW9UcmFjayA9IHRoaXMuc2NyZWVuU3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF07XHJcbiAgICAgIFxyXG4gICAgICAvLyBTdG9yZSBvcmlnaW5hbCB2aWRlbyB0cmFja1xyXG4gICAgICBpZiAodGhpcy5sb2NhbFN0cmVhbSkge1xyXG4gICAgICAgIHRoaXMub3JpZ2luYWxWaWRlb1RyYWNrID0gdGhpcy5sb2NhbFN0cmVhbS5nZXRWaWRlb1RyYWNrcygpWzBdIHx8IG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEhhbmRsZSB3aGVuIHVzZXIgc3RvcHMgc2hhcmluZyB2aWEgYnJvd3NlciBVSVxyXG4gICAgICB2aWRlb1RyYWNrLm9uZW5kZWQgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ/CflqXvuI8gU2NyZWVuIHNoYXJlIGVuZGVkIGJ5IHVzZXInKTtcclxuICAgICAgICB0aGlzLnN0b3BTY3JlZW5TaGFyZSgpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gUmVwbGFjZSB2aWRlbyB0cmFjayBpbiBwZWVyIGNvbm5lY3Rpb25cclxuICAgICAgaWYgKHRoaXMucGVlckNvbm5lY3Rpb24gJiYgdGhpcy5sb2NhbFN0cmVhbSkge1xyXG4gICAgICAgIGNvbnN0IHNlbmRlciA9IHRoaXMucGVlckNvbm5lY3Rpb24uZ2V0U2VuZGVycygpLmZpbmQocyA9PiBzLnRyYWNrPy5raW5kID09PSAndmlkZW8nKTtcclxuICAgICAgICBpZiAoc2VuZGVyKSB7XHJcbiAgICAgICAgICBhd2FpdCBzZW5kZXIucmVwbGFjZVRyYWNrKHZpZGVvVHJhY2spO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ+KchSBSZXBsYWNlZCB2aWRlbyB0cmFjayB3aXRoIHNjcmVlbiBzaGFyZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5pc1NjcmVlblNoYXJpbmcgPSB0cnVlO1xyXG4gICAgICByZXR1cm4gdGhpcy5zY3JlZW5TdHJlYW07XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3Igc3RhcnRpbmcgc2NyZWVuIHNoYXJlOicsIGVycm9yKTtcclxuICAgICAgdGhpcy5jYWxsYmFja3Mub25FcnJvcj8uKGVycm9yIGFzIEVycm9yKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBzdG9wU2NyZWVuU2hhcmUoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zb2xlLmxvZygn8J+Wpe+4jyBTdG9wcGluZyBzY3JlZW4gc2hhcmUnKTtcclxuICAgIFxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gU3RvcCBzY3JlZW4gc3RyZWFtIHRyYWNrc1xyXG4gICAgICBpZiAodGhpcy5zY3JlZW5TdHJlYW0pIHtcclxuICAgICAgICB0aGlzLnNjcmVlblN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHRyYWNrLnN0b3AoKSk7XHJcbiAgICAgICAgdGhpcy5zY3JlZW5TdHJlYW0gPSBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIHZpZGVvIHRyYWNrXHJcbiAgICAgIGlmICh0aGlzLnBlZXJDb25uZWN0aW9uICYmIHRoaXMub3JpZ2luYWxWaWRlb1RyYWNrKSB7XHJcbiAgICAgICAgY29uc3Qgc2VuZGVyID0gdGhpcy5wZWVyQ29ubmVjdGlvbi5nZXRTZW5kZXJzKCkuZmluZChzID0+IHMudHJhY2s/LmtpbmQgPT09ICd2aWRlbycpO1xyXG4gICAgICAgIGlmIChzZW5kZXIpIHtcclxuICAgICAgICAgIGF3YWl0IHNlbmRlci5yZXBsYWNlVHJhY2sodGhpcy5vcmlnaW5hbFZpZGVvVHJhY2spO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ+KchSBSZXN0b3JlZCBvcmlnaW5hbCB2aWRlbyB0cmFjaycpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICh0aGlzLnBlZXJDb25uZWN0aW9uICYmIHRoaXMuY2FsbFR5cGUgPT09ICd2aWRlbycpIHtcclxuICAgICAgICAvLyBSZS1hY3F1aXJlIGNhbWVyYSBpZiBvcmlnaW5hbCB0cmFjayBpcyBnb25lXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IG5ld1N0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHsgdmlkZW86IHRydWUgfSk7XHJcbiAgICAgICAgICBjb25zdCBuZXdWaWRlb1RyYWNrID0gbmV3U3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF07XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGNvbnN0IHNlbmRlciA9IHRoaXMucGVlckNvbm5lY3Rpb24uZ2V0U2VuZGVycygpLmZpbmQocyA9PiBzLnRyYWNrPy5raW5kID09PSAndmlkZW8nKTtcclxuICAgICAgICAgIGlmIChzZW5kZXIpIHtcclxuICAgICAgICAgICAgYXdhaXQgc2VuZGVyLnJlcGxhY2VUcmFjayhuZXdWaWRlb1RyYWNrKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ+KchSBBY3F1aXJlZCBuZXcgdmlkZW8gdHJhY2snKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gVXBkYXRlIGxvY2FsIHN0cmVhbVxyXG4gICAgICAgICAgaWYgKHRoaXMubG9jYWxTdHJlYW0pIHtcclxuICAgICAgICAgICAgY29uc3Qgb2xkVmlkZW9UcmFjayA9IHRoaXMubG9jYWxTdHJlYW0uZ2V0VmlkZW9UcmFja3MoKVswXTtcclxuICAgICAgICAgICAgaWYgKG9sZFZpZGVvVHJhY2spIHtcclxuICAgICAgICAgICAgICB0aGlzLmxvY2FsU3RyZWFtLnJlbW92ZVRyYWNrKG9sZFZpZGVvVHJhY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubG9jYWxTdHJlYW0uYWRkVHJhY2sobmV3VmlkZW9UcmFjayk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uTG9jYWxTdHJlYW0/Lih0aGlzLmxvY2FsU3RyZWFtKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIHJlLWFjcXVpcmluZyBjYW1lcmE6JywgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5pc1NjcmVlblNoYXJpbmcgPSBmYWxzZTtcclxuICAgICAgdGhpcy5vcmlnaW5hbFZpZGVvVHJhY2sgPSBudWxsO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIHN0b3BwaW5nIHNjcmVlbiBzaGFyZTonLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB0b2dnbGVNdXRlKCk6IGJvb2xlYW4ge1xyXG4gICAgaWYgKHRoaXMubG9jYWxTdHJlYW0pIHtcclxuICAgICAgY29uc3QgYXVkaW9UcmFjayA9IHRoaXMubG9jYWxTdHJlYW0uZ2V0QXVkaW9UcmFja3MoKVswXTtcclxuICAgICAgaWYgKGF1ZGlvVHJhY2spIHtcclxuICAgICAgICBhdWRpb1RyYWNrLmVuYWJsZWQgPSAhYXVkaW9UcmFjay5lbmFibGVkO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn46kIE1pYyAke2F1ZGlvVHJhY2suZW5hYmxlZCA/ICd1bm11dGVkJyA6ICdtdXRlZCd9YCk7XHJcbiAgICAgICAgcmV0dXJuICFhdWRpb1RyYWNrLmVuYWJsZWQ7IC8vIFJldHVybiBpc011dGVkIHN0YXRlXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHRvZ2dsZVZpZGVvKCk6IGJvb2xlYW4ge1xyXG4gICAgaWYgKHRoaXMubG9jYWxTdHJlYW0gJiYgIXRoaXMuaXNTY3JlZW5TaGFyaW5nKSB7XHJcbiAgICAgIGNvbnN0IHZpZGVvVHJhY2sgPSB0aGlzLmxvY2FsU3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF07XHJcbiAgICAgIGlmICh2aWRlb1RyYWNrKSB7XHJcbiAgICAgICAgdmlkZW9UcmFjay5lbmFibGVkID0gIXZpZGVvVHJhY2suZW5hYmxlZDtcclxuICAgICAgICBjb25zb2xlLmxvZyhg8J+TuSBWaWRlbyAke3ZpZGVvVHJhY2suZW5hYmxlZCA/ICdlbmFibGVkJyA6ICdkaXNhYmxlZCd9YCk7XHJcbiAgICAgICAgcmV0dXJuIHZpZGVvVHJhY2suZW5hYmxlZDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBnZXRJc1NjcmVlblNoYXJpbmcoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5pc1NjcmVlblNoYXJpbmc7XHJcbiAgfVxyXG5cclxuICBzdG9wTG9jYWxTdHJlYW0oKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5sb2NhbFN0cmVhbSkge1xyXG4gICAgICB0aGlzLmxvY2FsU3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xyXG4gICAgICAgIHRyYWNrLnN0b3AoKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhg4o+577iPIFN0b3BwZWQgJHt0cmFjay5raW5kfSB0cmFja2ApO1xyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5sb2NhbFN0cmVhbSA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBlbmRDYWxsKCk6IHZvaWQge1xyXG4gICAgY29uc29sZS5sb2coJ/Cfk7QgRW5kaW5nIGNhbGwnKTtcclxuICAgIFxyXG4gICAgLy8gU3RvcCBzY3JlZW4gc2hhcmUgaWYgYWN0aXZlXHJcbiAgICBpZiAodGhpcy5pc1NjcmVlblNoYXJpbmcpIHtcclxuICAgICAgdGhpcy5zdG9wU2NyZWVuU2hhcmUoKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gU3RvcCBsb2NhbCBzdHJlYW1cclxuICAgIHRoaXMuc3RvcExvY2FsU3RyZWFtKCk7XHJcbiAgICBcclxuICAgIC8vIFN0b3AgcmVtb3RlIHN0cmVhbVxyXG4gICAgaWYgKHRoaXMucmVtb3RlU3RyZWFtKSB7XHJcbiAgICAgIHRoaXMucmVtb3RlU3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4gdHJhY2suc3RvcCgpKTtcclxuICAgICAgdGhpcy5yZW1vdGVTdHJlYW0gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBDbG9zZSBwZWVyIGNvbm5lY3Rpb25cclxuICAgIGlmICh0aGlzLnBlZXJDb25uZWN0aW9uKSB7XHJcbiAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24uY2xvc2UoKTtcclxuICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbiA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFJlc2V0IHN0YXRlXHJcbiAgICB0aGlzLnBlbmRpbmdJY2VDYW5kaWRhdGVzID0gW107XHJcbiAgICB0aGlzLmlzSW5pdGlhdG9yID0gZmFsc2U7XHJcbiAgICB0aGlzLnJlbW90ZVVzZXJJZCA9ICcnO1xyXG4gICAgdGhpcy5jYWxsSWQgPSAnJztcclxuICAgIHRoaXMub3JpZ2luYWxWaWRlb1RyYWNrID0gbnVsbDtcclxuICAgIHRoaXMuaXNTY3JlZW5TaGFyaW5nID0gZmFsc2U7XHJcbiAgICBcclxuICAgIHRoaXMuY2FsbGJhY2tzLm9uQ2FsbEVuZGVkPy4oKTtcclxuICB9XHJcblxyXG4gIGdldExvY2FsU3RyZWFtKCk6IE1lZGlhU3RyZWFtIHwgbnVsbCB7XHJcbiAgICByZXR1cm4gdGhpcy5sb2NhbFN0cmVhbTtcclxuICB9XHJcblxyXG4gIGdldFJlbW90ZVN0cmVhbSgpOiBNZWRpYVN0cmVhbSB8IG51bGwge1xyXG4gICAgcmV0dXJuIHRoaXMucmVtb3RlU3RyZWFtO1xyXG4gIH1cclxuXHJcbiAgZ2V0UGVlckNvbm5lY3Rpb24oKTogUlRDUGVlckNvbm5lY3Rpb24gfCBudWxsIHtcclxuICAgIHJldHVybiB0aGlzLnBlZXJDb25uZWN0aW9uO1xyXG4gIH1cclxuXHJcbiAgZ2V0Q2FsbElkKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdGhpcy5jYWxsSWQ7XHJcbiAgfVxyXG5cclxuICBnZXRSZW1vdGVVc2VySWQoKTogc3RyaW5nIHtcclxuICAgIHJldHVybiB0aGlzLnJlbW90ZVVzZXJJZDtcclxuICB9XHJcbn1cclxuXHJcbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcclxuZXhwb3J0IGNvbnN0IHdlYlJUQ1NlcnZpY2UgPSBuZXcgV2ViUlRDU2VydmljZSgpO1xyXG5leHBvcnQgZGVmYXVsdCB3ZWJSVENTZXJ2aWNlO1xyXG5cclxuIl0sIm5hbWVzIjpbInNvY2tldFNlcnZpY2UiLCJJQ0VfU0VSVkVSUyIsImljZVNlcnZlcnMiLCJ1cmxzIiwiaWNlQ2FuZGlkYXRlUG9vbFNpemUiLCJjaGVja1dlYlJUQ1N1cHBvcnQiLCJzdXBwb3J0ZWQiLCJlcnJvciIsIndpbmRvdyIsImlzU2VjdXJlQ29udGV4dCIsImlzTG9jYWxob3N0IiwibG9jYXRpb24iLCJob3N0bmFtZSIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImdldFVzZXJNZWRpYSIsIlJUQ1BlZXJDb25uZWN0aW9uIiwiV2ViUlRDU2VydmljZSIsInNldENhbGxiYWNrcyIsImNhbGxiYWNrcyIsImluaXRpYWxpemVNZWRpYSIsInR5cGUiLCJzdXBwb3J0IiwiRXJyb3IiLCJjb25zb2xlIiwib25FcnJvciIsInN0b3BMb2NhbFN0cmVhbSIsImNvbnN0cmFpbnRzIiwiYXVkaW8iLCJlY2hvQ2FuY2VsbGF0aW9uIiwibm9pc2VTdXBwcmVzc2lvbiIsImF1dG9HYWluQ29udHJvbCIsInZpZGVvIiwid2lkdGgiLCJpZGVhbCIsIm1heCIsImhlaWdodCIsImZyYW1lUmF0ZSIsImZhY2luZ01vZGUiLCJsb2ciLCJsb2NhbFN0cmVhbSIsImdldFRyYWNrcyIsIm1hcCIsInQiLCJraW5kIiwibGFiZWwiLCJjYWxsVHlwZSIsIm9uTG9jYWxTdHJlYW0iLCJlcnJvck1lc3NhZ2UiLCJuYW1lIiwiY3VzdG9tRXJyb3IiLCJjcmVhdGVQZWVyQ29ubmVjdGlvbiIsInBlZXJDb25uZWN0aW9uIiwiY2xvc2UiLCJmb3JFYWNoIiwidHJhY2siLCJhZGRUcmFjayIsIm9udHJhY2siLCJldmVudCIsInJlbW90ZVN0cmVhbSIsIk1lZGlhU3RyZWFtIiwic3RyZWFtcyIsIm9uUmVtb3RlU3RyZWFtIiwicmVtb3RlVXNlcklkIiwib25pY2VjYW5kaWRhdGUiLCJjYW5kaWRhdGUiLCJzZW5kSWNlQ2FuZGlkYXRlIiwidG9KU09OIiwidG8iLCJvbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSIsInN0YXRlIiwiY29ubmVjdGlvblN0YXRlIiwib25Db25uZWN0aW9uU3RhdGVDaGFuZ2UiLCJvbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSIsImljZUNvbm5lY3Rpb25TdGF0ZSIsIm9uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlIiwib25pY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZSIsImljZUdhdGhlcmluZ1N0YXRlIiwicGVuZGluZ0ljZUNhbmRpZGF0ZXMiLCJsZW5ndGgiLCJhZGRJY2VDYW5kaWRhdGUiLCJpbml0aWF0ZUNhbGwiLCJjYWxsSWQiLCJpc0luaXRpYXRvciIsIm9mZmVyIiwiY3JlYXRlT2ZmZXIiLCJvZmZlclRvUmVjZWl2ZUF1ZGlvIiwib2ZmZXJUb1JlY2VpdmVWaWRlbyIsInNldExvY2FsRGVzY3JpcHRpb24iLCJjYWxsVXNlciIsInVzZXJUb0NhbGwiLCJzaWduYWxEYXRhIiwiYWNjZXB0Q2FsbCIsInNldFJlbW90ZURlc2NyaXB0aW9uIiwiUlRDU2Vzc2lvbkRlc2NyaXB0aW9uIiwiYW5zd2VyIiwiY3JlYXRlQW5zd2VyIiwiYW5zd2VyQ2FsbCIsInNpZ25hbCIsImhhbmRsZUFuc3dlciIsInJlbW90ZURlc2NyaXB0aW9uIiwicHVzaCIsIlJUQ0ljZUNhbmRpZGF0ZSIsInN0YXJ0U2NyZWVuU2hhcmUiLCJzY3JlZW5TdHJlYW0iLCJnZXREaXNwbGF5TWVkaWEiLCJjdXJzb3IiLCJkaXNwbGF5U3VyZmFjZSIsInZpZGVvVHJhY2siLCJnZXRWaWRlb1RyYWNrcyIsIm9yaWdpbmFsVmlkZW9UcmFjayIsIm9uZW5kZWQiLCJzdG9wU2NyZWVuU2hhcmUiLCJzZW5kZXIiLCJnZXRTZW5kZXJzIiwiZmluZCIsInMiLCJyZXBsYWNlVHJhY2siLCJpc1NjcmVlblNoYXJpbmciLCJzdG9wIiwibmV3U3RyZWFtIiwibmV3VmlkZW9UcmFjayIsIm9sZFZpZGVvVHJhY2siLCJyZW1vdmVUcmFjayIsInRvZ2dsZU11dGUiLCJhdWRpb1RyYWNrIiwiZ2V0QXVkaW9UcmFja3MiLCJlbmFibGVkIiwidG9nZ2xlVmlkZW8iLCJnZXRJc1NjcmVlblNoYXJpbmciLCJlbmRDYWxsIiwib25DYWxsRW5kZWQiLCJnZXRMb2NhbFN0cmVhbSIsImdldFJlbW90ZVN0cmVhbSIsImdldFBlZXJDb25uZWN0aW9uIiwiZ2V0Q2FsbElkIiwiZ2V0UmVtb3RlVXNlcklkIiwid2ViUlRDU2VydmljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/webrtc.ts\n"));

/***/ })

});