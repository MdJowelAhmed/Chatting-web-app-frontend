/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/simple-peer";
exports.ids = ["vendor-chunks/simple-peer"];
exports.modules = {

/***/ "(ssr)/./node_modules/simple-peer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/simple-peer/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ const debug = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\")(\"simple-peer\");\nconst getBrowserRTC = __webpack_require__(/*! get-browser-rtc */ \"(ssr)/./node_modules/get-browser-rtc/index.js\");\nconst randombytes = __webpack_require__(/*! randombytes */ \"(ssr)/./node_modules/randombytes/index.js\");\nconst stream = __webpack_require__(/*! readable-stream */ \"(ssr)/./node_modules/readable-stream/readable.js\");\nconst queueMicrotask = __webpack_require__(/*! queue-microtask */ \"(ssr)/./node_modules/queue-microtask/index.js\") // TODO: remove when Node 10 is not supported\n;\nconst errCode = __webpack_require__(/*! err-code */ \"(ssr)/./node_modules/err-code/index.js\");\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\");\nconst MAX_BUFFERED_AMOUNT = 64 * 1024;\nconst ICECOMPLETE_TIMEOUT = 5 * 1000;\nconst CHANNEL_CLOSING_TIMEOUT = 5 * 1000;\n// HACK: Filter trickle lines when trickle is disabled #354\nfunction filterTrickle(sdp) {\n    return sdp.replace(/a=ice-options:trickle\\s\\n/g, \"\");\n}\nfunction warn(message) {\n    console.warn(message);\n}\n/**\n * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.\n * Duplex stream.\n * @param {Object} opts\n */ class Peer extends stream.Duplex {\n    constructor(opts){\n        opts = Object.assign({\n            allowHalfOpen: false\n        }, opts);\n        super(opts);\n        this._id = randombytes(4).toString(\"hex\").slice(0, 7);\n        this._debug(\"new peer %o\", opts);\n        this.channelName = opts.initiator ? opts.channelName || randombytes(20).toString(\"hex\") : null;\n        this.initiator = opts.initiator || false;\n        this.channelConfig = opts.channelConfig || Peer.channelConfig;\n        this.channelNegotiated = this.channelConfig.negotiated;\n        this.config = Object.assign({}, Peer.config, opts.config);\n        this.offerOptions = opts.offerOptions || {};\n        this.answerOptions = opts.answerOptions || {};\n        this.sdpTransform = opts.sdpTransform || ((sdp)=>sdp);\n        this.streams = opts.streams || (opts.stream ? [\n            opts.stream\n        ] : [] // support old \"stream\" option\n        );\n        this.trickle = opts.trickle !== undefined ? opts.trickle : true;\n        this.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false;\n        this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT;\n        this.destroyed = false;\n        this.destroying = false;\n        this._connected = false;\n        this.remoteAddress = undefined;\n        this.remoteFamily = undefined;\n        this.remotePort = undefined;\n        this.localAddress = undefined;\n        this.localFamily = undefined;\n        this.localPort = undefined;\n        this._wrtc = opts.wrtc && typeof opts.wrtc === \"object\" ? opts.wrtc : getBrowserRTC();\n        if (!this._wrtc) {\n            if (true) {\n                throw errCode(new Error(\"No WebRTC support: Specify `opts.wrtc` option in this environment\"), \"ERR_WEBRTC_SUPPORT\");\n            } else {}\n        }\n        this._pcReady = false;\n        this._channelReady = false;\n        this._iceComplete = false // ice candidate trickle done (got null candidate)\n        ;\n        this._iceCompleteTimer = null // send an offer/answer anyway after some timeout\n        ;\n        this._channel = null;\n        this._pendingCandidates = [];\n        this._isNegotiating = false // is this peer waiting for negotiation to complete?\n        ;\n        this._firstNegotiation = true;\n        this._batchedNegotiation = false // batch synchronous negotiations\n        ;\n        this._queuedNegotiation = false // is there a queued negotiation request?\n        ;\n        this._sendersAwaitingStable = [];\n        this._senderMap = new Map();\n        this._closingInterval = null;\n        this._remoteTracks = [];\n        this._remoteStreams = [];\n        this._chunk = null;\n        this._cb = null;\n        this._interval = null;\n        try {\n            this._pc = new this._wrtc.RTCPeerConnection(this.config);\n        } catch (err) {\n            this.destroy(errCode(err, \"ERR_PC_CONSTRUCTOR\"));\n            return;\n        }\n        // We prefer feature detection whenever possible, but sometimes that's not\n        // possible for certain implementations.\n        this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === \"number\";\n        this._pc.oniceconnectionstatechange = ()=>{\n            this._onIceStateChange();\n        };\n        this._pc.onicegatheringstatechange = ()=>{\n            this._onIceStateChange();\n        };\n        this._pc.onconnectionstatechange = ()=>{\n            this._onConnectionStateChange();\n        };\n        this._pc.onsignalingstatechange = ()=>{\n            this._onSignalingStateChange();\n        };\n        this._pc.onicecandidate = (event)=>{\n            this._onIceCandidate(event);\n        };\n        // HACK: Fix for odd Firefox behavior, see: https://github.com/feross/simple-peer/pull/783\n        if (typeof this._pc.peerIdentity === \"object\") {\n            this._pc.peerIdentity.catch((err)=>{\n                this.destroy(errCode(err, \"ERR_PC_PEER_IDENTITY\"));\n            });\n        }\n        // Other spec events, unused by this implementation:\n        // - onconnectionstatechange\n        // - onicecandidateerror\n        // - onfingerprintfailure\n        // - onnegotiationneeded\n        if (this.initiator || this.channelNegotiated) {\n            this._setupData({\n                channel: this._pc.createDataChannel(this.channelName, this.channelConfig)\n            });\n        } else {\n            this._pc.ondatachannel = (event)=>{\n                this._setupData(event);\n            };\n        }\n        if (this.streams) {\n            this.streams.forEach((stream)=>{\n                this.addStream(stream);\n            });\n        }\n        this._pc.ontrack = (event)=>{\n            this._onTrack(event);\n        };\n        this._debug(\"initial negotiation\");\n        this._needsNegotiation();\n        this._onFinishBound = ()=>{\n            this._onFinish();\n        };\n        this.once(\"finish\", this._onFinishBound);\n    }\n    get bufferSize() {\n        return this._channel && this._channel.bufferedAmount || 0;\n    }\n    // HACK: it's possible channel.readyState is \"closing\" before peer.destroy() fires\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\n    get connected() {\n        return this._connected && this._channel.readyState === \"open\";\n    }\n    address() {\n        return {\n            port: this.localPort,\n            family: this.localFamily,\n            address: this.localAddress\n        };\n    }\n    signal(data) {\n        if (this.destroying) return;\n        if (this.destroyed) throw errCode(new Error(\"cannot signal after peer is destroyed\"), \"ERR_DESTROYED\");\n        if (typeof data === \"string\") {\n            try {\n                data = JSON.parse(data);\n            } catch (err) {\n                data = {};\n            }\n        }\n        this._debug(\"signal()\");\n        if (data.renegotiate && this.initiator) {\n            this._debug(\"got request to renegotiate\");\n            this._needsNegotiation();\n        }\n        if (data.transceiverRequest && this.initiator) {\n            this._debug(\"got request for transceiver\");\n            this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init);\n        }\n        if (data.candidate) {\n            if (this._pc.remoteDescription && this._pc.remoteDescription.type) {\n                this._addIceCandidate(data.candidate);\n            } else {\n                this._pendingCandidates.push(data.candidate);\n            }\n        }\n        if (data.sdp) {\n            this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(data)).then(()=>{\n                if (this.destroyed) return;\n                this._pendingCandidates.forEach((candidate)=>{\n                    this._addIceCandidate(candidate);\n                });\n                this._pendingCandidates = [];\n                if (this._pc.remoteDescription.type === \"offer\") this._createAnswer();\n            }).catch((err)=>{\n                this.destroy(errCode(err, \"ERR_SET_REMOTE_DESCRIPTION\"));\n            });\n        }\n        if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {\n            this.destroy(errCode(new Error(\"signal() called with invalid signal data\"), \"ERR_SIGNALING\"));\n        }\n    }\n    _addIceCandidate(candidate) {\n        const iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate);\n        this._pc.addIceCandidate(iceCandidateObj).catch((err)=>{\n            if (!iceCandidateObj.address || iceCandidateObj.address.endsWith(\".local\")) {\n                warn(\"Ignoring unsupported ICE candidate.\");\n            } else {\n                this.destroy(errCode(err, \"ERR_ADD_ICE_CANDIDATE\"));\n            }\n        });\n    }\n    /**\n   * Send text/binary data to the remote peer.\n   * @param {ArrayBufferView|ArrayBuffer|Buffer|string|Blob} chunk\n   */ send(chunk) {\n        if (this.destroying) return;\n        if (this.destroyed) throw errCode(new Error(\"cannot send after peer is destroyed\"), \"ERR_DESTROYED\");\n        this._channel.send(chunk);\n    }\n    /**\n   * Add a Transceiver to the connection.\n   * @param {String} kind\n   * @param {Object} init\n   */ addTransceiver(kind, init) {\n        if (this.destroying) return;\n        if (this.destroyed) throw errCode(new Error(\"cannot addTransceiver after peer is destroyed\"), \"ERR_DESTROYED\");\n        this._debug(\"addTransceiver()\");\n        if (this.initiator) {\n            try {\n                this._pc.addTransceiver(kind, init);\n                this._needsNegotiation();\n            } catch (err) {\n                this.destroy(errCode(err, \"ERR_ADD_TRANSCEIVER\"));\n            }\n        } else {\n            this.emit(\"signal\", {\n                type: \"transceiverRequest\",\n                transceiverRequest: {\n                    kind,\n                    init\n                }\n            });\n        }\n    }\n    /**\n   * Add a MediaStream to the connection.\n   * @param {MediaStream} stream\n   */ addStream(stream) {\n        if (this.destroying) return;\n        if (this.destroyed) throw errCode(new Error(\"cannot addStream after peer is destroyed\"), \"ERR_DESTROYED\");\n        this._debug(\"addStream()\");\n        stream.getTracks().forEach((track)=>{\n            this.addTrack(track, stream);\n        });\n    }\n    /**\n   * Add a MediaStreamTrack to the connection.\n   * @param {MediaStreamTrack} track\n   * @param {MediaStream} stream\n   */ addTrack(track, stream) {\n        if (this.destroying) return;\n        if (this.destroyed) throw errCode(new Error(\"cannot addTrack after peer is destroyed\"), \"ERR_DESTROYED\");\n        this._debug(\"addTrack()\");\n        const submap = this._senderMap.get(track) || new Map() // nested Maps map [track, stream] to sender\n        ;\n        let sender = submap.get(stream);\n        if (!sender) {\n            sender = this._pc.addTrack(track, stream);\n            submap.set(stream, sender);\n            this._senderMap.set(track, submap);\n            this._needsNegotiation();\n        } else if (sender.removed) {\n            throw errCode(new Error(\"Track has been removed. You should enable/disable tracks that you want to re-add.\"), \"ERR_SENDER_REMOVED\");\n        } else {\n            throw errCode(new Error(\"Track has already been added to that stream.\"), \"ERR_SENDER_ALREADY_ADDED\");\n        }\n    }\n    /**\n   * Replace a MediaStreamTrack by another in the connection.\n   * @param {MediaStreamTrack} oldTrack\n   * @param {MediaStreamTrack} newTrack\n   * @param {MediaStream} stream\n   */ replaceTrack(oldTrack, newTrack, stream) {\n        if (this.destroying) return;\n        if (this.destroyed) throw errCode(new Error(\"cannot replaceTrack after peer is destroyed\"), \"ERR_DESTROYED\");\n        this._debug(\"replaceTrack()\");\n        const submap = this._senderMap.get(oldTrack);\n        const sender = submap ? submap.get(stream) : null;\n        if (!sender) {\n            throw errCode(new Error(\"Cannot replace track that was never added.\"), \"ERR_TRACK_NOT_ADDED\");\n        }\n        if (newTrack) this._senderMap.set(newTrack, submap);\n        if (sender.replaceTrack != null) {\n            sender.replaceTrack(newTrack);\n        } else {\n            this.destroy(errCode(new Error(\"replaceTrack is not supported in this browser\"), \"ERR_UNSUPPORTED_REPLACETRACK\"));\n        }\n    }\n    /**\n   * Remove a MediaStreamTrack from the connection.\n   * @param {MediaStreamTrack} track\n   * @param {MediaStream} stream\n   */ removeTrack(track, stream) {\n        if (this.destroying) return;\n        if (this.destroyed) throw errCode(new Error(\"cannot removeTrack after peer is destroyed\"), \"ERR_DESTROYED\");\n        this._debug(\"removeSender()\");\n        const submap = this._senderMap.get(track);\n        const sender = submap ? submap.get(stream) : null;\n        if (!sender) {\n            throw errCode(new Error(\"Cannot remove track that was never added.\"), \"ERR_TRACK_NOT_ADDED\");\n        }\n        try {\n            sender.removed = true;\n            this._pc.removeTrack(sender);\n        } catch (err) {\n            if (err.name === \"NS_ERROR_UNEXPECTED\") {\n                this._sendersAwaitingStable.push(sender) // HACK: Firefox must wait until (signalingState === stable) https://bugzilla.mozilla.org/show_bug.cgi?id=1133874\n                ;\n            } else {\n                this.destroy(errCode(err, \"ERR_REMOVE_TRACK\"));\n            }\n        }\n        this._needsNegotiation();\n    }\n    /**\n   * Remove a MediaStream from the connection.\n   * @param {MediaStream} stream\n   */ removeStream(stream) {\n        if (this.destroying) return;\n        if (this.destroyed) throw errCode(new Error(\"cannot removeStream after peer is destroyed\"), \"ERR_DESTROYED\");\n        this._debug(\"removeSenders()\");\n        stream.getTracks().forEach((track)=>{\n            this.removeTrack(track, stream);\n        });\n    }\n    _needsNegotiation() {\n        this._debug(\"_needsNegotiation\");\n        if (this._batchedNegotiation) return; // batch synchronous renegotiations\n        this._batchedNegotiation = true;\n        queueMicrotask(()=>{\n            this._batchedNegotiation = false;\n            if (this.initiator || !this._firstNegotiation) {\n                this._debug(\"starting batched negotiation\");\n                this.negotiate();\n            } else {\n                this._debug(\"non-initiator initial negotiation request discarded\");\n            }\n            this._firstNegotiation = false;\n        });\n    }\n    negotiate() {\n        if (this.destroying) return;\n        if (this.destroyed) throw errCode(new Error(\"cannot negotiate after peer is destroyed\"), \"ERR_DESTROYED\");\n        if (this.initiator) {\n            if (this._isNegotiating) {\n                this._queuedNegotiation = true;\n                this._debug(\"already negotiating, queueing\");\n            } else {\n                this._debug(\"start negotiation\");\n                setTimeout(()=>{\n                    this._createOffer();\n                }, 0);\n            }\n        } else {\n            if (this._isNegotiating) {\n                this._queuedNegotiation = true;\n                this._debug(\"already negotiating, queueing\");\n            } else {\n                this._debug(\"requesting negotiation from initiator\");\n                this.emit(\"signal\", {\n                    type: \"renegotiate\",\n                    renegotiate: true\n                });\n            }\n        }\n        this._isNegotiating = true;\n    }\n    // TODO: Delete this method once readable-stream is updated to contain a default\n    // implementation of destroy() that automatically calls _destroy()\n    // See: https://github.com/nodejs/readable-stream/issues/283\n    destroy(err) {\n        this._destroy(err, ()=>{});\n    }\n    _destroy(err, cb) {\n        if (this.destroyed || this.destroying) return;\n        this.destroying = true;\n        this._debug(\"destroying (error: %s)\", err && (err.message || err));\n        queueMicrotask(()=>{\n            this.destroyed = true;\n            this.destroying = false;\n            this._debug(\"destroy (error: %s)\", err && (err.message || err));\n            this.readable = this.writable = false;\n            if (!this._readableState.ended) this.push(null);\n            if (!this._writableState.finished) this.end();\n            this._connected = false;\n            this._pcReady = false;\n            this._channelReady = false;\n            this._remoteTracks = null;\n            this._remoteStreams = null;\n            this._senderMap = null;\n            clearInterval(this._closingInterval);\n            this._closingInterval = null;\n            clearInterval(this._interval);\n            this._interval = null;\n            this._chunk = null;\n            this._cb = null;\n            if (this._onFinishBound) this.removeListener(\"finish\", this._onFinishBound);\n            this._onFinishBound = null;\n            if (this._channel) {\n                try {\n                    this._channel.close();\n                } catch (err) {}\n                // allow events concurrent with destruction to be handled\n                this._channel.onmessage = null;\n                this._channel.onopen = null;\n                this._channel.onclose = null;\n                this._channel.onerror = null;\n            }\n            if (this._pc) {\n                try {\n                    this._pc.close();\n                } catch (err) {}\n                // allow events concurrent with destruction to be handled\n                this._pc.oniceconnectionstatechange = null;\n                this._pc.onicegatheringstatechange = null;\n                this._pc.onsignalingstatechange = null;\n                this._pc.onicecandidate = null;\n                this._pc.ontrack = null;\n                this._pc.ondatachannel = null;\n            }\n            this._pc = null;\n            this._channel = null;\n            if (err) this.emit(\"error\", err);\n            this.emit(\"close\");\n            cb();\n        });\n    }\n    _setupData(event) {\n        if (!event.channel) {\n            // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),\n            // which is invalid behavior. Handle it gracefully.\n            // See: https://github.com/feross/simple-peer/issues/163\n            return this.destroy(errCode(new Error(\"Data channel event is missing `channel` property\"), \"ERR_DATA_CHANNEL\"));\n        }\n        this._channel = event.channel;\n        this._channel.binaryType = \"arraybuffer\";\n        if (typeof this._channel.bufferedAmountLowThreshold === \"number\") {\n            this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT;\n        }\n        this.channelName = this._channel.label;\n        this._channel.onmessage = (event)=>{\n            this._onChannelMessage(event);\n        };\n        this._channel.onbufferedamountlow = ()=>{\n            this._onChannelBufferedAmountLow();\n        };\n        this._channel.onopen = ()=>{\n            this._onChannelOpen();\n        };\n        this._channel.onclose = ()=>{\n            this._onChannelClose();\n        };\n        this._channel.onerror = (event)=>{\n            const err = event.error instanceof Error ? event.error : new Error(`Datachannel error: ${event.message} ${event.filename}:${event.lineno}:${event.colno}`);\n            this.destroy(errCode(err, \"ERR_DATA_CHANNEL\"));\n        };\n        // HACK: Chrome will sometimes get stuck in readyState \"closing\", let's check for this condition\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\n        let isClosing = false;\n        this._closingInterval = setInterval(()=>{\n            if (this._channel && this._channel.readyState === \"closing\") {\n                if (isClosing) this._onChannelClose() // closing timed out: equivalent to onclose firing\n                ;\n                isClosing = true;\n            } else {\n                isClosing = false;\n            }\n        }, CHANNEL_CLOSING_TIMEOUT);\n    }\n    _read() {}\n    _write(chunk, encoding, cb) {\n        if (this.destroyed) return cb(errCode(new Error(\"cannot write after peer is destroyed\"), \"ERR_DATA_CHANNEL\"));\n        if (this._connected) {\n            try {\n                this.send(chunk);\n            } catch (err) {\n                return this.destroy(errCode(err, \"ERR_DATA_CHANNEL\"));\n            }\n            if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\n                this._debug(\"start backpressure: bufferedAmount %d\", this._channel.bufferedAmount);\n                this._cb = cb;\n            } else {\n                cb(null);\n            }\n        } else {\n            this._debug(\"write before connect\");\n            this._chunk = chunk;\n            this._cb = cb;\n        }\n    }\n    // When stream finishes writing, close socket. Half open connections are not\n    // supported.\n    _onFinish() {\n        if (this.destroyed) return;\n        // Wait a bit before destroying so the socket flushes.\n        // TODO: is there a more reliable way to accomplish this?\n        const destroySoon = ()=>{\n            setTimeout(()=>this.destroy(), 1000);\n        };\n        if (this._connected) {\n            destroySoon();\n        } else {\n            this.once(\"connect\", destroySoon);\n        }\n    }\n    _startIceCompleteTimeout() {\n        if (this.destroyed) return;\n        if (this._iceCompleteTimer) return;\n        this._debug(\"started iceComplete timeout\");\n        this._iceCompleteTimer = setTimeout(()=>{\n            if (!this._iceComplete) {\n                this._iceComplete = true;\n                this._debug(\"iceComplete timeout completed\");\n                this.emit(\"iceTimeout\");\n                this.emit(\"_iceComplete\");\n            }\n        }, this.iceCompleteTimeout);\n    }\n    _createOffer() {\n        if (this.destroyed) return;\n        this._pc.createOffer(this.offerOptions).then((offer)=>{\n            if (this.destroyed) return;\n            if (!this.trickle && !this.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp);\n            offer.sdp = this.sdpTransform(offer.sdp);\n            const sendOffer = ()=>{\n                if (this.destroyed) return;\n                const signal = this._pc.localDescription || offer;\n                this._debug(\"signal\");\n                this.emit(\"signal\", {\n                    type: signal.type,\n                    sdp: signal.sdp\n                });\n            };\n            const onSuccess = ()=>{\n                this._debug(\"createOffer success\");\n                if (this.destroyed) return;\n                if (this.trickle || this._iceComplete) sendOffer();\n                else this.once(\"_iceComplete\", sendOffer) // wait for candidates\n                ;\n            };\n            const onError = (err)=>{\n                this.destroy(errCode(err, \"ERR_SET_LOCAL_DESCRIPTION\"));\n            };\n            this._pc.setLocalDescription(offer).then(onSuccess).catch(onError);\n        }).catch((err)=>{\n            this.destroy(errCode(err, \"ERR_CREATE_OFFER\"));\n        });\n    }\n    _requestMissingTransceivers() {\n        if (this._pc.getTransceivers) {\n            this._pc.getTransceivers().forEach((transceiver)=>{\n                if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {\n                    transceiver.requested = true // HACK: Safari returns negotiated transceivers with a null mid\n                    ;\n                    this.addTransceiver(transceiver.sender.track.kind);\n                }\n            });\n        }\n    }\n    _createAnswer() {\n        if (this.destroyed) return;\n        this._pc.createAnswer(this.answerOptions).then((answer)=>{\n            if (this.destroyed) return;\n            if (!this.trickle && !this.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp);\n            answer.sdp = this.sdpTransform(answer.sdp);\n            const sendAnswer = ()=>{\n                if (this.destroyed) return;\n                const signal = this._pc.localDescription || answer;\n                this._debug(\"signal\");\n                this.emit(\"signal\", {\n                    type: signal.type,\n                    sdp: signal.sdp\n                });\n                if (!this.initiator) this._requestMissingTransceivers();\n            };\n            const onSuccess = ()=>{\n                if (this.destroyed) return;\n                if (this.trickle || this._iceComplete) sendAnswer();\n                else this.once(\"_iceComplete\", sendAnswer);\n            };\n            const onError = (err)=>{\n                this.destroy(errCode(err, \"ERR_SET_LOCAL_DESCRIPTION\"));\n            };\n            this._pc.setLocalDescription(answer).then(onSuccess).catch(onError);\n        }).catch((err)=>{\n            this.destroy(errCode(err, \"ERR_CREATE_ANSWER\"));\n        });\n    }\n    _onConnectionStateChange() {\n        if (this.destroyed) return;\n        if (this._pc.connectionState === \"failed\") {\n            this.destroy(errCode(new Error(\"Connection failed.\"), \"ERR_CONNECTION_FAILURE\"));\n        }\n    }\n    _onIceStateChange() {\n        if (this.destroyed) return;\n        const iceConnectionState = this._pc.iceConnectionState;\n        const iceGatheringState = this._pc.iceGatheringState;\n        this._debug(\"iceStateChange (connection: %s) (gathering: %s)\", iceConnectionState, iceGatheringState);\n        this.emit(\"iceStateChange\", iceConnectionState, iceGatheringState);\n        if (iceConnectionState === \"connected\" || iceConnectionState === \"completed\") {\n            this._pcReady = true;\n            this._maybeReady();\n        }\n        if (iceConnectionState === \"failed\") {\n            this.destroy(errCode(new Error(\"Ice connection failed.\"), \"ERR_ICE_CONNECTION_FAILURE\"));\n        }\n        if (iceConnectionState === \"closed\") {\n            this.destroy(errCode(new Error(\"Ice connection closed.\"), \"ERR_ICE_CONNECTION_CLOSED\"));\n        }\n    }\n    getStats(cb) {\n        // statreports can come with a value array instead of properties\n        const flattenValues = (report)=>{\n            if (Object.prototype.toString.call(report.values) === \"[object Array]\") {\n                report.values.forEach((value)=>{\n                    Object.assign(report, value);\n                });\n            }\n            return report;\n        };\n        // Promise-based getStats() (standard)\n        if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {\n            this._pc.getStats().then((res)=>{\n                const reports = [];\n                res.forEach((report)=>{\n                    reports.push(flattenValues(report));\n                });\n                cb(null, reports);\n            }, (err)=>cb(err));\n        // Single-parameter callback-based getStats() (non-standard)\n        } else if (this._pc.getStats.length > 0) {\n            this._pc.getStats((res)=>{\n                // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed\n                if (this.destroyed) return;\n                const reports = [];\n                res.result().forEach((result)=>{\n                    const report = {};\n                    result.names().forEach((name)=>{\n                        report[name] = result.stat(name);\n                    });\n                    report.id = result.id;\n                    report.type = result.type;\n                    report.timestamp = result.timestamp;\n                    reports.push(flattenValues(report));\n                });\n                cb(null, reports);\n            }, (err)=>cb(err));\n        // Unknown browser, skip getStats() since it's anyone's guess which style of\n        // getStats() they implement.\n        } else {\n            cb(null, []);\n        }\n    }\n    _maybeReady() {\n        this._debug(\"maybeReady pc %s channel %s\", this._pcReady, this._channelReady);\n        if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return;\n        this._connecting = true;\n        // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339\n        const findCandidatePair = ()=>{\n            if (this.destroyed) return;\n            this.getStats((err, items)=>{\n                if (this.destroyed) return;\n                // Treat getStats error as non-fatal. It's not essential.\n                if (err) items = [];\n                const remoteCandidates = {};\n                const localCandidates = {};\n                const candidatePairs = {};\n                let foundSelectedCandidatePair = false;\n                items.forEach((item)=>{\n                    // TODO: Once all browsers support the hyphenated stats report types, remove\n                    // the non-hypenated ones\n                    if (item.type === \"remotecandidate\" || item.type === \"remote-candidate\") {\n                        remoteCandidates[item.id] = item;\n                    }\n                    if (item.type === \"localcandidate\" || item.type === \"local-candidate\") {\n                        localCandidates[item.id] = item;\n                    }\n                    if (item.type === \"candidatepair\" || item.type === \"candidate-pair\") {\n                        candidatePairs[item.id] = item;\n                    }\n                });\n                const setSelectedCandidatePair = (selectedCandidatePair)=>{\n                    foundSelectedCandidatePair = true;\n                    let local = localCandidates[selectedCandidatePair.localCandidateId];\n                    if (local && (local.ip || local.address)) {\n                        // Spec\n                        this.localAddress = local.ip || local.address;\n                        this.localPort = Number(local.port);\n                    } else if (local && local.ipAddress) {\n                        // Firefox\n                        this.localAddress = local.ipAddress;\n                        this.localPort = Number(local.portNumber);\n                    } else if (typeof selectedCandidatePair.googLocalAddress === \"string\") {\n                        // TODO: remove this once Chrome 58 is released\n                        local = selectedCandidatePair.googLocalAddress.split(\":\");\n                        this.localAddress = local[0];\n                        this.localPort = Number(local[1]);\n                    }\n                    if (this.localAddress) {\n                        this.localFamily = this.localAddress.includes(\":\") ? \"IPv6\" : \"IPv4\";\n                    }\n                    let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId];\n                    if (remote && (remote.ip || remote.address)) {\n                        // Spec\n                        this.remoteAddress = remote.ip || remote.address;\n                        this.remotePort = Number(remote.port);\n                    } else if (remote && remote.ipAddress) {\n                        // Firefox\n                        this.remoteAddress = remote.ipAddress;\n                        this.remotePort = Number(remote.portNumber);\n                    } else if (typeof selectedCandidatePair.googRemoteAddress === \"string\") {\n                        // TODO: remove this once Chrome 58 is released\n                        remote = selectedCandidatePair.googRemoteAddress.split(\":\");\n                        this.remoteAddress = remote[0];\n                        this.remotePort = Number(remote[1]);\n                    }\n                    if (this.remoteAddress) {\n                        this.remoteFamily = this.remoteAddress.includes(\":\") ? \"IPv6\" : \"IPv4\";\n                    }\n                    this._debug(\"connect local: %s:%s remote: %s:%s\", this.localAddress, this.localPort, this.remoteAddress, this.remotePort);\n                };\n                items.forEach((item)=>{\n                    // Spec-compliant\n                    if (item.type === \"transport\" && item.selectedCandidatePairId) {\n                        setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId]);\n                    }\n                    // Old implementations\n                    if (item.type === \"googCandidatePair\" && item.googActiveConnection === \"true\" || (item.type === \"candidatepair\" || item.type === \"candidate-pair\") && item.selected) {\n                        setSelectedCandidatePair(item);\n                    }\n                });\n                // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates\n                // But wait until at least 1 candidate pair is available\n                if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {\n                    setTimeout(findCandidatePair, 100);\n                    return;\n                } else {\n                    this._connecting = false;\n                    this._connected = true;\n                }\n                if (this._chunk) {\n                    try {\n                        this.send(this._chunk);\n                    } catch (err) {\n                        return this.destroy(errCode(err, \"ERR_DATA_CHANNEL\"));\n                    }\n                    this._chunk = null;\n                    this._debug('sent chunk from \"write before connect\"');\n                    const cb = this._cb;\n                    this._cb = null;\n                    cb(null);\n                }\n                // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,\n                // fallback to using setInterval to implement backpressure.\n                if (typeof this._channel.bufferedAmountLowThreshold !== \"number\") {\n                    this._interval = setInterval(()=>this._onInterval(), 150);\n                    if (this._interval.unref) this._interval.unref();\n                }\n                this._debug(\"connect\");\n                this.emit(\"connect\");\n            });\n        };\n        findCandidatePair();\n    }\n    _onInterval() {\n        if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\n            return;\n        }\n        this._onChannelBufferedAmountLow();\n    }\n    _onSignalingStateChange() {\n        if (this.destroyed) return;\n        if (this._pc.signalingState === \"stable\") {\n            this._isNegotiating = false;\n            // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'\n            this._debug(\"flushing sender queue\", this._sendersAwaitingStable);\n            this._sendersAwaitingStable.forEach((sender)=>{\n                this._pc.removeTrack(sender);\n                this._queuedNegotiation = true;\n            });\n            this._sendersAwaitingStable = [];\n            if (this._queuedNegotiation) {\n                this._debug(\"flushing negotiation queue\");\n                this._queuedNegotiation = false;\n                this._needsNegotiation() // negotiate again\n                ;\n            } else {\n                this._debug(\"negotiated\");\n                this.emit(\"negotiated\");\n            }\n        }\n        this._debug(\"signalingStateChange %s\", this._pc.signalingState);\n        this.emit(\"signalingStateChange\", this._pc.signalingState);\n    }\n    _onIceCandidate(event) {\n        if (this.destroyed) return;\n        if (event.candidate && this.trickle) {\n            this.emit(\"signal\", {\n                type: \"candidate\",\n                candidate: {\n                    candidate: event.candidate.candidate,\n                    sdpMLineIndex: event.candidate.sdpMLineIndex,\n                    sdpMid: event.candidate.sdpMid\n                }\n            });\n        } else if (!event.candidate && !this._iceComplete) {\n            this._iceComplete = true;\n            this.emit(\"_iceComplete\");\n        }\n        // as soon as we've received one valid candidate start timeout\n        if (event.candidate) {\n            this._startIceCompleteTimeout();\n        }\n    }\n    _onChannelMessage(event) {\n        if (this.destroyed) return;\n        let data = event.data;\n        if (data instanceof ArrayBuffer) data = Buffer.from(data);\n        this.push(data);\n    }\n    _onChannelBufferedAmountLow() {\n        if (this.destroyed || !this._cb) return;\n        this._debug(\"ending backpressure: bufferedAmount %d\", this._channel.bufferedAmount);\n        const cb = this._cb;\n        this._cb = null;\n        cb(null);\n    }\n    _onChannelOpen() {\n        if (this._connected || this.destroyed) return;\n        this._debug(\"on channel open\");\n        this._channelReady = true;\n        this._maybeReady();\n    }\n    _onChannelClose() {\n        if (this.destroyed) return;\n        this._debug(\"on channel close\");\n        this.destroy();\n    }\n    _onTrack(event) {\n        if (this.destroyed) return;\n        event.streams.forEach((eventStream)=>{\n            this._debug(\"on track\");\n            this.emit(\"track\", event.track, eventStream);\n            this._remoteTracks.push({\n                track: event.track,\n                stream: eventStream\n            });\n            if (this._remoteStreams.some((remoteStream)=>{\n                return remoteStream.id === eventStream.id;\n            })) return; // Only fire one 'stream' event, even though there may be multiple tracks per stream\n            this._remoteStreams.push(eventStream);\n            queueMicrotask(()=>{\n                this._debug(\"on stream\");\n                this.emit(\"stream\", eventStream) // ensure all tracks have been added\n                ;\n            });\n        });\n    }\n    _debug() {\n        const args = [].slice.call(arguments);\n        args[0] = \"[\" + this._id + \"] \" + args[0];\n        debug.apply(null, args);\n    }\n}\nPeer.WEBRTC_SUPPORT = !!getBrowserRTC();\n/**\n * Expose peer and data channel config for overriding all Peer\n * instances. Otherwise, just set opts.config or opts.channelConfig\n * when constructing a Peer.\n */ Peer.config = {\n    iceServers: [\n        {\n            urls: [\n                \"stun:stun.l.google.com:19302\",\n                \"stun:global.stun.twilio.com:3478\"\n            ]\n        }\n    ],\n    sdpSemantics: \"unified-plan\"\n};\nPeer.channelConfig = {};\nmodule.exports = Peer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2ltcGxlLXBlZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsa0ZBQWtGLEdBQ2xGLE1BQU1BLFFBQVFDLG1CQUFPQSxDQUFDLHdEQUFTO0FBQy9CLE1BQU1DLGdCQUFnQkQsbUJBQU9BLENBQUM7QUFDOUIsTUFBTUUsY0FBY0YsbUJBQU9BLENBQUM7QUFDNUIsTUFBTUcsU0FBU0gsbUJBQU9BLENBQUM7QUFDdkIsTUFBTUksaUJBQWlCSixtQkFBT0EsQ0FBQyx3RUFBbUIsNkNBQTZDOztBQUMvRixNQUFNSyxVQUFVTCxtQkFBT0EsQ0FBQztBQUN4QixNQUFNLEVBQUVNLE1BQU0sRUFBRSxHQUFHTixtQkFBT0EsQ0FBQztBQUUzQixNQUFNTyxzQkFBc0IsS0FBSztBQUNqQyxNQUFNQyxzQkFBc0IsSUFBSTtBQUNoQyxNQUFNQywwQkFBMEIsSUFBSTtBQUVwQywyREFBMkQ7QUFDM0QsU0FBU0MsY0FBZUMsR0FBRztJQUN6QixPQUFPQSxJQUFJQyxPQUFPLENBQUMsOEJBQThCO0FBQ25EO0FBRUEsU0FBU0MsS0FBTUMsT0FBTztJQUNwQkMsUUFBUUYsSUFBSSxDQUFDQztBQUNmO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU1FLGFBQWFiLE9BQU9jLE1BQU07SUFDOUJDLFlBQWFDLElBQUksQ0FBRTtRQUNqQkEsT0FBT0MsT0FBT0MsTUFBTSxDQUFDO1lBQ25CQyxlQUFlO1FBQ2pCLEdBQUdIO1FBRUgsS0FBSyxDQUFDQTtRQUVOLElBQUksQ0FBQ0ksR0FBRyxHQUFHckIsWUFBWSxHQUFHc0IsUUFBUSxDQUFDLE9BQU9DLEtBQUssQ0FBQyxHQUFHO1FBQ25ELElBQUksQ0FBQ0MsTUFBTSxDQUFDLGVBQWVQO1FBRTNCLElBQUksQ0FBQ1EsV0FBVyxHQUFHUixLQUFLUyxTQUFTLEdBQzdCVCxLQUFLUSxXQUFXLElBQUl6QixZQUFZLElBQUlzQixRQUFRLENBQUMsU0FDN0M7UUFFSixJQUFJLENBQUNJLFNBQVMsR0FBR1QsS0FBS1Ms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WUFFQSxJQUFJLElBQUksQ0FBQ3pMLGNBQWMsQ0FBQzBMLElBQUksQ0FBQ0MsQ0FBQUE7Z0JBQzNCLE9BQU9BLGFBQWFyQyxFQUFFLEtBQUttQyxZQUFZbkMsRUFBRTtZQUMzQyxJQUFJLFFBQU8sb0ZBQW9GO1lBRS9GLElBQUksQ0FBQ3RKLGNBQWMsQ0FBQ3NELElBQUksQ0FBQ21JO1lBQ3pCelAsZUFBZTtnQkFDYixJQUFJLENBQUNzQixNQUFNLENBQUM7Z0JBQ1osSUFBSSxDQUFDMkcsSUFBSSxDQUFDLFVBQVV3SCxhQUFhLG9DQUFvQzs7WUFDdkU7UUFDRjtJQUNGO0lBRUFuTyxTQUFVO1FBQ1IsTUFBTXNPLE9BQU8sRUFBRSxDQUFDdk8sS0FBSyxDQUFDd0wsSUFBSSxDQUFDZ0Q7UUFDM0JELElBQUksQ0FBQyxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUN6TyxHQUFHLEdBQUcsT0FBT3lPLElBQUksQ0FBQyxFQUFFO1FBQ3pDalEsTUFBTW1RLEtBQUssQ0FBQyxNQUFNRjtJQUNwQjtBQUNGO0FBRUFoUCxLQUFLbVAsY0FBYyxHQUFHLENBQUMsQ0FBQ2xRO0FBRXhCOzs7O0NBSUMsR0FDRGUsS0FBS2dCLE1BQU0sR0FBRztJQUNab08sWUFBWTtRQUNWO1lBQ0VDLE1BQU07Z0JBQ0o7Z0JBQ0E7YUFDRDtRQUNIO0tBQ0Q7SUFDREMsY0FBYztBQUNoQjtBQUVBdFAsS0FBS2EsYUFBYSxHQUFHLENBQUM7QUFFdEIwTyxPQUFPQyxPQUFPLEdBQUd4UCIsInNvdXJjZXMiOlsid2VicGFjazovL3doYXRzYXBwLWNsb25lLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3NpbXBsZS1wZWVyL2luZGV4LmpzP2FlOWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIHNpbXBsZS1wZWVyLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NpbXBsZS1wZWVyJylcbmNvbnN0IGdldEJyb3dzZXJSVEMgPSByZXF1aXJlKCdnZXQtYnJvd3Nlci1ydGMnKVxuY29uc3QgcmFuZG9tYnl0ZXMgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpXG5jb25zdCBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxuY29uc3QgcXVldWVNaWNyb3Rhc2sgPSByZXF1aXJlKCdxdWV1ZS1taWNyb3Rhc2snKSAvLyBUT0RPOiByZW1vdmUgd2hlbiBOb2RlIDEwIGlzIG5vdCBzdXBwb3J0ZWRcbmNvbnN0IGVyckNvZGUgPSByZXF1aXJlKCdlcnItY29kZScpXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcblxuY29uc3QgTUFYX0JVRkZFUkVEX0FNT1VOVCA9IDY0ICogMTAyNFxuY29uc3QgSUNFQ09NUExFVEVfVElNRU9VVCA9IDUgKiAxMDAwXG5jb25zdCBDSEFOTkVMX0NMT1NJTkdfVElNRU9VVCA9IDUgKiAxMDAwXG5cbi8vIEhBQ0s6IEZpbHRlciB0cmlja2xlIGxpbmVzIHdoZW4gdHJpY2tsZSBpcyBkaXNhYmxlZCAjMzU0XG5mdW5jdGlvbiBmaWx0ZXJUcmlja2xlIChzZHApIHtcbiAgcmV0dXJuIHNkcC5yZXBsYWNlKC9hPWljZS1vcHRpb25zOnRyaWNrbGVcXHNcXG4vZywgJycpXG59XG5cbmZ1bmN0aW9uIHdhcm4gKG1lc3NhZ2UpIHtcbiAgY29uc29sZS53YXJuKG1lc3NhZ2UpXG59XG5cbi8qKlxuICogV2ViUlRDIHBlZXIgY29ubmVjdGlvbi4gU2FtZSBBUEkgYXMgbm9kZSBjb3JlIGBuZXQuU29ja2V0YCwgcGx1cyBhIGZldyBleHRyYSBtZXRob2RzLlxuICogRHVwbGV4IHN0cmVhbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cbmNsYXNzIFBlZXIgZXh0ZW5kcyBzdHJlYW0uRHVwbGV4IHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBvcHRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBhbGxvd0hhbGZPcGVuOiBmYWxzZVxuICAgIH0sIG9wdHMpXG5cbiAgICBzdXBlcihvcHRzKVxuXG4gICAgdGhpcy5faWQgPSByYW5kb21ieXRlcyg0KS50b1N0cmluZygnaGV4Jykuc2xpY2UoMCwgNylcbiAgICB0aGlzLl9kZWJ1ZygnbmV3IHBlZXIgJW8nLCBvcHRzKVxuXG4gICAgdGhpcy5jaGFubmVsTmFtZSA9IG9wdHMuaW5pdGlhdG9yXG4gICAgICA/IG9wdHMuY2hhbm5lbE5hbWUgfHwgcmFuZG9tYnl0ZXMoMjApLnRvU3RyaW5nKCdoZXgnKVxuICAgICAgOiBudWxsXG5cbiAgICB0aGlzLmluaXRpYXRvciA9IG9wdHMuaW5pdGlhdG9yIHx8IGZhbHNlXG4gICAgdGhpcy5jaGFubmVsQ29uZmlnID0gb3B0cy5jaGFubmVsQ29uZmlnIHx8IFBlZXIuY2hhbm5lbENvbmZpZ1xuICAgIHRoaXMuY2hhbm5lbE5lZ290aWF0ZWQgPSB0aGlzLmNoYW5uZWxDb25maWcubmVnb3RpYXRlZFxuICAgIHRoaXMuY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgUGVlci5jb25maWcsIG9wdHMuY29uZmlnKVxuICAgIHRoaXMub2ZmZXJPcHRpb25zID0gb3B0cy5vZmZlck9wdGlvbnMgfHwge31cbiAgICB0aGlzLmFuc3dlck9wdGlvbnMgPSBvcHRzLmFuc3dlck9wdGlvbnMgfHwge31cbiAgICB0aGlzLnNkcFRyYW5zZm9ybSA9IG9wdHMuc2RwVHJhbnNmb3JtIHx8IChzZHAgPT4gc2RwKVxuICAgIHRoaXMuc3RyZWFtcyA9IG9wdHMuc3RyZWFtcyB8fCAob3B0cy5zdHJlYW0gPyBbb3B0cy5zdHJlYW1dIDogW10pIC8vIHN1cHBvcnQgb2xkIFwic3RyZWFtXCIgb3B0aW9uXG4gICAgdGhpcy50cmlja2xlID0gb3B0cy50cmlja2xlICE9PSB1bmRlZmluZWQgPyBvcHRzLnRyaWNrbGUgOiB0cnVlXG4gICAgdGhpcy5hbGxvd0hhbGZUcmlja2xlID0gb3B0cy5hbGxvd0hhbGZUcmlja2xlICE9PSB1bmRlZmluZWQgPyBvcHRzLmFsbG93SGFsZlRyaWNrbGUgOiBmYWxzZVxuICAgIHRoaXMuaWNlQ29tcGxldGVUaW1lb3V0ID0gb3B0cy5pY2VDb21wbGV0ZVRpbWVvdXQgfHwgSUNFQ09NUExFVEVfVElNRU9VVFxuXG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZVxuICAgIHRoaXMuZGVzdHJveWluZyA9IGZhbHNlXG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2VcblxuICAgIHRoaXMucmVtb3RlQWRkcmVzcyA9IHVuZGVmaW5lZFxuICAgIHRoaXMucmVtb3RlRmFtaWx5ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5yZW1vdGVQb3J0ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5sb2NhbEFkZHJlc3MgPSB1bmRlZmluZWRcbiAgICB0aGlzLmxvY2FsRmFtaWx5ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5sb2NhbFBvcnQgPSB1bmRlZmluZWRcblxuICAgIHRoaXMuX3dydGMgPSAob3B0cy53cnRjICYmIHR5cGVvZiBvcHRzLndydGMgPT09ICdvYmplY3QnKVxuICAgICAgPyBvcHRzLndydGNcbiAgICAgIDogZ2V0QnJvd3NlclJUQygpXG5cbiAgICBpZiAoIXRoaXMuX3dydGMpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignTm8gV2ViUlRDIHN1cHBvcnQ6IFNwZWNpZnkgYG9wdHMud3J0Y2Agb3B0aW9uIGluIHRoaXMgZW52aXJvbm1lbnQnKSwgJ0VSUl9XRUJSVENfU1VQUE9SVCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignTm8gV2ViUlRDIHN1cHBvcnQ6IE5vdCBhIHN1cHBvcnRlZCBicm93c2VyJyksICdFUlJfV0VCUlRDX1NVUFBPUlQnKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3BjUmVhZHkgPSBmYWxzZVxuICAgIHRoaXMuX2NoYW5uZWxSZWFkeSA9IGZhbHNlXG4gICAgdGhpcy5faWNlQ29tcGxldGUgPSBmYWxzZSAvLyBpY2UgY2FuZGlkYXRlIHRyaWNrbGUgZG9uZSAoZ290IG51bGwgY2FuZGlkYXRlKVxuICAgIHRoaXMuX2ljZUNvbXBsZXRlVGltZXIgPSBudWxsIC8vIHNlbmQgYW4gb2ZmZXIvYW5zd2VyIGFueXdheSBhZnRlciBzb21lIHRpbWVvdXRcbiAgICB0aGlzLl9jaGFubmVsID0gbnVsbFxuICAgIHRoaXMuX3BlbmRpbmdDYW5kaWRhdGVzID0gW11cblxuICAgIHRoaXMuX2lzTmVnb3RpYXRpbmcgPSBmYWxzZSAvLyBpcyB0aGlzIHBlZXIgd2FpdGluZyBmb3IgbmVnb3RpYXRpb24gdG8gY29tcGxldGU/XG4gICAgdGhpcy5fZmlyc3ROZWdvdGlhdGlvbiA9IHRydWVcbiAgICB0aGlzLl9iYXRjaGVkTmVnb3RpYXRpb24gPSBmYWxzZSAvLyBiYXRjaCBzeW5jaHJvbm91cyBuZWdvdGlhdGlvbnNcbiAgICB0aGlzLl9xdWV1ZWROZWdvdGlhdGlvbiA9IGZhbHNlIC8vIGlzIHRoZXJlIGEgcXVldWVkIG5lZ290aWF0aW9uIHJlcXVlc3Q/XG4gICAgdGhpcy5fc2VuZGVyc0F3YWl0aW5nU3RhYmxlID0gW11cbiAgICB0aGlzLl9zZW5kZXJNYXAgPSBuZXcgTWFwKClcbiAgICB0aGlzLl9jbG9zaW5nSW50ZXJ2YWwgPSBudWxsXG5cbiAgICB0aGlzLl9yZW1vdGVUcmFja3MgPSBbXVxuICAgIHRoaXMuX3JlbW90ZVN0cmVhbXMgPSBbXVxuXG4gICAgdGhpcy5fY2h1bmsgPSBudWxsXG4gICAgdGhpcy5fY2IgPSBudWxsXG4gICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsXG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5fcGMgPSBuZXcgKHRoaXMuX3dydGMuUlRDUGVlckNvbm5lY3Rpb24pKHRoaXMuY29uZmlnKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUoZXJyLCAnRVJSX1BDX0NPTlNUUlVDVE9SJykpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBXZSBwcmVmZXIgZmVhdHVyZSBkZXRlY3Rpb24gd2hlbmV2ZXIgcG9zc2libGUsIGJ1dCBzb21ldGltZXMgdGhhdCdzIG5vdFxuICAgIC8vIHBvc3NpYmxlIGZvciBjZXJ0YWluIGltcGxlbWVudGF0aW9ucy5cbiAgICB0aGlzLl9pc1JlYWN0TmF0aXZlV2VicnRjID0gdHlwZW9mIHRoaXMuX3BjLl9wZWVyQ29ubmVjdGlvbklkID09PSAnbnVtYmVyJ1xuXG4gICAgdGhpcy5fcGMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9vbkljZVN0YXRlQ2hhbmdlKClcbiAgICB9XG4gICAgdGhpcy5fcGMub25pY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX29uSWNlU3RhdGVDaGFuZ2UoKVxuICAgIH1cbiAgICB0aGlzLl9wYy5vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX29uQ29ubmVjdGlvblN0YXRlQ2hhbmdlKClcbiAgICB9XG4gICAgdGhpcy5fcGMub25zaWduYWxpbmdzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX29uU2lnbmFsaW5nU3RhdGVDaGFuZ2UoKVxuICAgIH1cbiAgICB0aGlzLl9wYy5vbmljZWNhbmRpZGF0ZSA9IGV2ZW50ID0+IHtcbiAgICAgIHRoaXMuX29uSWNlQ2FuZGlkYXRlKGV2ZW50KVxuICAgIH1cblxuICAgIC8vIEhBQ0s6IEZpeCBmb3Igb2RkIEZpcmVmb3ggYmVoYXZpb3IsIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9zaW1wbGUtcGVlci9wdWxsLzc4M1xuICAgIGlmICh0eXBlb2YgdGhpcy5fcGMucGVlcklkZW50aXR5ID09PSAnb2JqZWN0Jykge1xuICAgICAgdGhpcy5fcGMucGVlcklkZW50aXR5LmNhdGNoKGVyciA9PiB7XG4gICAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKGVyciwgJ0VSUl9QQ19QRUVSX0lERU5USVRZJykpXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIE90aGVyIHNwZWMgZXZlbnRzLCB1bnVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvbjpcbiAgICAvLyAtIG9uY29ubmVjdGlvbnN0YXRlY2hhbmdlXG4gICAgLy8gLSBvbmljZWNhbmRpZGF0ZWVycm9yXG4gICAgLy8gLSBvbmZpbmdlcnByaW50ZmFpbHVyZVxuICAgIC8vIC0gb25uZWdvdGlhdGlvbm5lZWRlZFxuXG4gICAgaWYgKHRoaXMuaW5pdGlhdG9yIHx8IHRoaXMuY2hhbm5lbE5lZ290aWF0ZWQpIHtcbiAgICAgIHRoaXMuX3NldHVwRGF0YSh7XG4gICAgICAgIGNoYW5uZWw6IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKHRoaXMuY2hhbm5lbE5hbWUsIHRoaXMuY2hhbm5lbENvbmZpZylcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3BjLm9uZGF0YWNoYW5uZWwgPSBldmVudCA9PiB7XG4gICAgICAgIHRoaXMuX3NldHVwRGF0YShldmVudClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdHJlYW1zKSB7XG4gICAgICB0aGlzLnN0cmVhbXMuZm9yRWFjaChzdHJlYW0gPT4ge1xuICAgICAgICB0aGlzLmFkZFN0cmVhbShzdHJlYW0pXG4gICAgICB9KVxuICAgIH1cbiAgICB0aGlzLl9wYy5vbnRyYWNrID0gZXZlbnQgPT4ge1xuICAgICAgdGhpcy5fb25UcmFjayhldmVudClcbiAgICB9XG5cbiAgICB0aGlzLl9kZWJ1ZygnaW5pdGlhbCBuZWdvdGlhdGlvbicpXG4gICAgdGhpcy5fbmVlZHNOZWdvdGlhdGlvbigpXG5cbiAgICB0aGlzLl9vbkZpbmlzaEJvdW5kID0gKCkgPT4ge1xuICAgICAgdGhpcy5fb25GaW5pc2goKVxuICAgIH1cbiAgICB0aGlzLm9uY2UoJ2ZpbmlzaCcsIHRoaXMuX29uRmluaXNoQm91bmQpXG4gIH1cblxuICBnZXQgYnVmZmVyU2l6ZSAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9jaGFubmVsICYmIHRoaXMuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnQpIHx8IDBcbiAgfVxuXG4gIC8vIEhBQ0s6IGl0J3MgcG9zc2libGUgY2hhbm5lbC5yZWFkeVN0YXRlIGlzIFwiY2xvc2luZ1wiIGJlZm9yZSBwZWVyLmRlc3Ryb3koKSBmaXJlc1xuICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04ODI3NDNcbiAgZ2V0IGNvbm5lY3RlZCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9jb25uZWN0ZWQgJiYgdGhpcy5fY2hhbm5lbC5yZWFkeVN0YXRlID09PSAnb3BlbicpXG4gIH1cblxuICBhZGRyZXNzICgpIHtcbiAgICByZXR1cm4geyBwb3J0OiB0aGlzLmxvY2FsUG9ydCwgZmFtaWx5OiB0aGlzLmxvY2FsRmFtaWx5LCBhZGRyZXNzOiB0aGlzLmxvY2FsQWRkcmVzcyB9XG4gIH1cblxuICBzaWduYWwgKGRhdGEpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95aW5nKSByZXR1cm5cbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdjYW5ub3Qgc2lnbmFsIGFmdGVyIHBlZXIgaXMgZGVzdHJveWVkJyksICdFUlJfREVTVFJPWUVEJylcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGRhdGEgPSB7fVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9kZWJ1Zygnc2lnbmFsKCknKVxuXG4gICAgaWYgKGRhdGEucmVuZWdvdGlhdGUgJiYgdGhpcy5pbml0aWF0b3IpIHtcbiAgICAgIHRoaXMuX2RlYnVnKCdnb3QgcmVxdWVzdCB0byByZW5lZ290aWF0ZScpXG4gICAgICB0aGlzLl9uZWVkc05lZ290aWF0aW9uKClcbiAgICB9XG4gICAgaWYgKGRhdGEudHJhbnNjZWl2ZXJSZXF1ZXN0ICYmIHRoaXMuaW5pdGlhdG9yKSB7XG4gICAgICB0aGlzLl9kZWJ1ZygnZ290IHJlcXVlc3QgZm9yIHRyYW5zY2VpdmVyJylcbiAgICAgIHRoaXMuYWRkVHJhbnNjZWl2ZXIoZGF0YS50cmFuc2NlaXZlclJlcXVlc3Qua2luZCwgZGF0YS50cmFuc2NlaXZlclJlcXVlc3QuaW5pdClcbiAgICB9XG4gICAgaWYgKGRhdGEuY2FuZGlkYXRlKSB7XG4gICAgICBpZiAodGhpcy5fcGMucmVtb3RlRGVzY3JpcHRpb24gJiYgdGhpcy5fcGMucmVtb3RlRGVzY3JpcHRpb24udHlwZSkge1xuICAgICAgICB0aGlzLl9hZGRJY2VDYW5kaWRhdGUoZGF0YS5jYW5kaWRhdGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wZW5kaW5nQ2FuZGlkYXRlcy5wdXNoKGRhdGEuY2FuZGlkYXRlKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGF0YS5zZHApIHtcbiAgICAgIHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG5ldyAodGhpcy5fd3J0Yy5SVENTZXNzaW9uRGVzY3JpcHRpb24pKGRhdGEpKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cblxuICAgICAgICAgIHRoaXMuX3BlbmRpbmdDYW5kaWRhdGVzLmZvckVhY2goY2FuZGlkYXRlID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2FkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpXG4gICAgICAgICAgfSlcbiAgICAgICAgICB0aGlzLl9wZW5kaW5nQ2FuZGlkYXRlcyA9IFtdXG5cbiAgICAgICAgICBpZiAodGhpcy5fcGMucmVtb3RlRGVzY3JpcHRpb24udHlwZSA9PT0gJ29mZmVyJykgdGhpcy5fY3JlYXRlQW5zd2VyKClcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUoZXJyLCAnRVJSX1NFVF9SRU1PVEVfREVTQ1JJUFRJT04nKSlcbiAgICAgICAgfSlcbiAgICB9XG4gICAgaWYgKCFkYXRhLnNkcCAmJiAhZGF0YS5jYW5kaWRhdGUgJiYgIWRhdGEucmVuZWdvdGlhdGUgJiYgIWRhdGEudHJhbnNjZWl2ZXJSZXF1ZXN0KSB7XG4gICAgICB0aGlzLmRlc3Ryb3koZXJyQ29kZShuZXcgRXJyb3IoJ3NpZ25hbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgc2lnbmFsIGRhdGEnKSwgJ0VSUl9TSUdOQUxJTkcnKSlcbiAgICB9XG4gIH1cblxuICBfYWRkSWNlQ2FuZGlkYXRlIChjYW5kaWRhdGUpIHtcbiAgICBjb25zdCBpY2VDYW5kaWRhdGVPYmogPSBuZXcgdGhpcy5fd3J0Yy5SVENJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKVxuICAgIHRoaXMuX3BjLmFkZEljZUNhbmRpZGF0ZShpY2VDYW5kaWRhdGVPYmopXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgaWYgKCFpY2VDYW5kaWRhdGVPYmouYWRkcmVzcyB8fCBpY2VDYW5kaWRhdGVPYmouYWRkcmVzcy5lbmRzV2l0aCgnLmxvY2FsJykpIHtcbiAgICAgICAgICB3YXJuKCdJZ25vcmluZyB1bnN1cHBvcnRlZCBJQ0UgY2FuZGlkYXRlLicpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUoZXJyLCAnRVJSX0FERF9JQ0VfQ0FORElEQVRFJykpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogU2VuZCB0ZXh0L2JpbmFyeSBkYXRhIHRvIHRoZSByZW1vdGUgcGVlci5cbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd8QXJyYXlCdWZmZXJ8QnVmZmVyfHN0cmluZ3xCbG9ifSBjaHVua1xuICAgKi9cbiAgc2VuZCAoY2h1bmspIHtcbiAgICBpZiAodGhpcy5kZXN0cm95aW5nKSByZXR1cm5cbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdjYW5ub3Qgc2VuZCBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZCcpLCAnRVJSX0RFU1RST1lFRCcpXG4gICAgdGhpcy5fY2hhbm5lbC5zZW5kKGNodW5rKVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIFRyYW5zY2VpdmVyIHRvIHRoZSBjb25uZWN0aW9uLlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2luZFxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5pdFxuICAgKi9cbiAgYWRkVHJhbnNjZWl2ZXIgKGtpbmQsIGluaXQpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95aW5nKSByZXR1cm5cbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdjYW5ub3QgYWRkVHJhbnNjZWl2ZXIgYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWQnKSwgJ0VSUl9ERVNUUk9ZRUQnKVxuICAgIHRoaXMuX2RlYnVnKCdhZGRUcmFuc2NlaXZlcigpJylcblxuICAgIGlmICh0aGlzLmluaXRpYXRvcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fcGMuYWRkVHJhbnNjZWl2ZXIoa2luZCwgaW5pdClcbiAgICAgICAgdGhpcy5fbmVlZHNOZWdvdGlhdGlvbigpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUoZXJyLCAnRVJSX0FERF9UUkFOU0NFSVZFUicpKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVtaXQoJ3NpZ25hbCcsIHsgLy8gcmVxdWVzdCBpbml0aWF0b3IgdG8gcmVuZWdvdGlhdGVcbiAgICAgICAgdHlwZTogJ3RyYW5zY2VpdmVyUmVxdWVzdCcsXG4gICAgICAgIHRyYW5zY2VpdmVyUmVxdWVzdDogeyBraW5kLCBpbml0IH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIE1lZGlhU3RyZWFtIHRvIHRoZSBjb25uZWN0aW9uLlxuICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBzdHJlYW1cbiAgICovXG4gIGFkZFN0cmVhbSAoc3RyZWFtKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWluZykgcmV0dXJuXG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignY2Fubm90IGFkZFN0cmVhbSBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZCcpLCAnRVJSX0RFU1RST1lFRCcpXG4gICAgdGhpcy5fZGVidWcoJ2FkZFN0cmVhbSgpJylcblxuICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgIHRoaXMuYWRkVHJhY2sodHJhY2ssIHN0cmVhbSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIE1lZGlhU3RyZWFtVHJhY2sgdG8gdGhlIGNvbm5lY3Rpb24uXG4gICAqIEBwYXJhbSB7TWVkaWFTdHJlYW1UcmFja30gdHJhY2tcbiAgICogQHBhcmFtIHtNZWRpYVN0cmVhbX0gc3RyZWFtXG4gICAqL1xuICBhZGRUcmFjayAodHJhY2ssIHN0cmVhbSkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3lpbmcpIHJldHVyblxuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ2Nhbm5vdCBhZGRUcmFjayBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZCcpLCAnRVJSX0RFU1RST1lFRCcpXG4gICAgdGhpcy5fZGVidWcoJ2FkZFRyYWNrKCknKVxuXG4gICAgY29uc3Qgc3VibWFwID0gdGhpcy5fc2VuZGVyTWFwLmdldCh0cmFjaykgfHwgbmV3IE1hcCgpIC8vIG5lc3RlZCBNYXBzIG1hcCBbdHJhY2ssIHN0cmVhbV0gdG8gc2VuZGVyXG4gICAgbGV0IHNlbmRlciA9IHN1Ym1hcC5nZXQoc3RyZWFtKVxuICAgIGlmICghc2VuZGVyKSB7XG4gICAgICBzZW5kZXIgPSB0aGlzLl9wYy5hZGRUcmFjayh0cmFjaywgc3RyZWFtKVxuICAgICAgc3VibWFwLnNldChzdHJlYW0sIHNlbmRlcilcbiAgICAgIHRoaXMuX3NlbmRlck1hcC5zZXQodHJhY2ssIHN1Ym1hcClcbiAgICAgIHRoaXMuX25lZWRzTmVnb3RpYXRpb24oKVxuICAgIH0gZWxzZSBpZiAoc2VuZGVyLnJlbW92ZWQpIHtcbiAgICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdUcmFjayBoYXMgYmVlbiByZW1vdmVkLiBZb3Ugc2hvdWxkIGVuYWJsZS9kaXNhYmxlIHRyYWNrcyB0aGF0IHlvdSB3YW50IHRvIHJlLWFkZC4nKSwgJ0VSUl9TRU5ERVJfUkVNT1ZFRCcpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdUcmFjayBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkIHRvIHRoYXQgc3RyZWFtLicpLCAnRVJSX1NFTkRFUl9BTFJFQURZX0FEREVEJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZSBhIE1lZGlhU3RyZWFtVHJhY2sgYnkgYW5vdGhlciBpbiB0aGUgY29ubmVjdGlvbi5cbiAgICogQHBhcmFtIHtNZWRpYVN0cmVhbVRyYWNrfSBvbGRUcmFja1xuICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtVHJhY2t9IG5ld1RyYWNrXG4gICAqIEBwYXJhbSB7TWVkaWFTdHJlYW19IHN0cmVhbVxuICAgKi9cbiAgcmVwbGFjZVRyYWNrIChvbGRUcmFjaywgbmV3VHJhY2ssIHN0cmVhbSkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3lpbmcpIHJldHVyblxuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ2Nhbm5vdCByZXBsYWNlVHJhY2sgYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWQnKSwgJ0VSUl9ERVNUUk9ZRUQnKVxuICAgIHRoaXMuX2RlYnVnKCdyZXBsYWNlVHJhY2soKScpXG5cbiAgICBjb25zdCBzdWJtYXAgPSB0aGlzLl9zZW5kZXJNYXAuZ2V0KG9sZFRyYWNrKVxuICAgIGNvbnN0IHNlbmRlciA9IHN1Ym1hcCA/IHN1Ym1hcC5nZXQoc3RyZWFtKSA6IG51bGxcbiAgICBpZiAoIXNlbmRlcikge1xuICAgICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ0Nhbm5vdCByZXBsYWNlIHRyYWNrIHRoYXQgd2FzIG5ldmVyIGFkZGVkLicpLCAnRVJSX1RSQUNLX05PVF9BRERFRCcpXG4gICAgfVxuICAgIGlmIChuZXdUcmFjaykgdGhpcy5fc2VuZGVyTWFwLnNldChuZXdUcmFjaywgc3VibWFwKVxuXG4gICAgaWYgKHNlbmRlci5yZXBsYWNlVHJhY2sgIT0gbnVsbCkge1xuICAgICAgc2VuZGVyLnJlcGxhY2VUcmFjayhuZXdUcmFjaylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUobmV3IEVycm9yKCdyZXBsYWNlVHJhY2sgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKSwgJ0VSUl9VTlNVUFBPUlRFRF9SRVBMQUNFVFJBQ0snKSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgTWVkaWFTdHJlYW1UcmFjayBmcm9tIHRoZSBjb25uZWN0aW9uLlxuICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtVHJhY2t9IHRyYWNrXG4gICAqIEBwYXJhbSB7TWVkaWFTdHJlYW19IHN0cmVhbVxuICAgKi9cbiAgcmVtb3ZlVHJhY2sgKHRyYWNrLCBzdHJlYW0pIHtcbiAgICBpZiAodGhpcy5kZXN0cm95aW5nKSByZXR1cm5cbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdjYW5ub3QgcmVtb3ZlVHJhY2sgYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWQnKSwgJ0VSUl9ERVNUUk9ZRUQnKVxuICAgIHRoaXMuX2RlYnVnKCdyZW1vdmVTZW5kZXIoKScpXG5cbiAgICBjb25zdCBzdWJtYXAgPSB0aGlzLl9zZW5kZXJNYXAuZ2V0KHRyYWNrKVxuICAgIGNvbnN0IHNlbmRlciA9IHN1Ym1hcCA/IHN1Ym1hcC5nZXQoc3RyZWFtKSA6IG51bGxcbiAgICBpZiAoIXNlbmRlcikge1xuICAgICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ0Nhbm5vdCByZW1vdmUgdHJhY2sgdGhhdCB3YXMgbmV2ZXIgYWRkZWQuJyksICdFUlJfVFJBQ0tfTk9UX0FEREVEJylcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHNlbmRlci5yZW1vdmVkID0gdHJ1ZVxuICAgICAgdGhpcy5fcGMucmVtb3ZlVHJhY2soc2VuZGVyKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyci5uYW1lID09PSAnTlNfRVJST1JfVU5FWFBFQ1RFRCcpIHtcbiAgICAgICAgdGhpcy5fc2VuZGVyc0F3YWl0aW5nU3RhYmxlLnB1c2goc2VuZGVyKSAvLyBIQUNLOiBGaXJlZm94IG11c3Qgd2FpdCB1bnRpbCAoc2lnbmFsaW5nU3RhdGUgPT09IHN0YWJsZSkgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTEzMzg3NFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUoZXJyLCAnRVJSX1JFTU9WRV9UUkFDSycpKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9uZWVkc05lZ290aWF0aW9uKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBNZWRpYVN0cmVhbSBmcm9tIHRoZSBjb25uZWN0aW9uLlxuICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBzdHJlYW1cbiAgICovXG4gIHJlbW92ZVN0cmVhbSAoc3RyZWFtKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWluZykgcmV0dXJuXG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignY2Fubm90IHJlbW92ZVN0cmVhbSBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZCcpLCAnRVJSX0RFU1RST1lFRCcpXG4gICAgdGhpcy5fZGVidWcoJ3JlbW92ZVNlbmRlcnMoKScpXG5cbiAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICB0aGlzLnJlbW92ZVRyYWNrKHRyYWNrLCBzdHJlYW0pXG4gICAgfSlcbiAgfVxuXG4gIF9uZWVkc05lZ290aWF0aW9uICgpIHtcbiAgICB0aGlzLl9kZWJ1ZygnX25lZWRzTmVnb3RpYXRpb24nKVxuICAgIGlmICh0aGlzLl9iYXRjaGVkTmVnb3RpYXRpb24pIHJldHVybiAvLyBiYXRjaCBzeW5jaHJvbm91cyByZW5lZ290aWF0aW9uc1xuICAgIHRoaXMuX2JhdGNoZWROZWdvdGlhdGlvbiA9IHRydWVcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICB0aGlzLl9iYXRjaGVkTmVnb3RpYXRpb24gPSBmYWxzZVxuICAgICAgaWYgKHRoaXMuaW5pdGlhdG9yIHx8ICF0aGlzLl9maXJzdE5lZ290aWF0aW9uKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdzdGFydGluZyBiYXRjaGVkIG5lZ290aWF0aW9uJylcbiAgICAgICAgdGhpcy5uZWdvdGlhdGUoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJ25vbi1pbml0aWF0b3IgaW5pdGlhbCBuZWdvdGlhdGlvbiByZXF1ZXN0IGRpc2NhcmRlZCcpXG4gICAgICB9XG4gICAgICB0aGlzLl9maXJzdE5lZ290aWF0aW9uID0gZmFsc2VcbiAgICB9KVxuICB9XG5cbiAgbmVnb3RpYXRlICgpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95aW5nKSByZXR1cm5cbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdjYW5ub3QgbmVnb3RpYXRlIGFmdGVyIHBlZXIgaXMgZGVzdHJveWVkJyksICdFUlJfREVTVFJPWUVEJylcblxuICAgIGlmICh0aGlzLmluaXRpYXRvcikge1xuICAgICAgaWYgKHRoaXMuX2lzTmVnb3RpYXRpbmcpIHtcbiAgICAgICAgdGhpcy5fcXVldWVkTmVnb3RpYXRpb24gPSB0cnVlXG4gICAgICAgIHRoaXMuX2RlYnVnKCdhbHJlYWR5IG5lZ290aWF0aW5nLCBxdWV1ZWluZycpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9kZWJ1Zygnc3RhcnQgbmVnb3RpYXRpb24nKVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgLy8gSEFDSzogQ2hyb21lIGNyYXNoZXMgaWYgd2UgaW1tZWRpYXRlbHkgY2FsbCBjcmVhdGVPZmZlclxuICAgICAgICAgIHRoaXMuX2NyZWF0ZU9mZmVyKClcbiAgICAgICAgfSwgMClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX2lzTmVnb3RpYXRpbmcpIHtcbiAgICAgICAgdGhpcy5fcXVldWVkTmVnb3RpYXRpb24gPSB0cnVlXG4gICAgICAgIHRoaXMuX2RlYnVnKCdhbHJlYWR5IG5lZ290aWF0aW5nLCBxdWV1ZWluZycpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9kZWJ1ZygncmVxdWVzdGluZyBuZWdvdGlhdGlvbiBmcm9tIGluaXRpYXRvcicpXG4gICAgICAgIHRoaXMuZW1pdCgnc2lnbmFsJywgeyAvLyByZXF1ZXN0IGluaXRpYXRvciB0byByZW5lZ290aWF0ZVxuICAgICAgICAgIHR5cGU6ICdyZW5lZ290aWF0ZScsXG4gICAgICAgICAgcmVuZWdvdGlhdGU6IHRydWVcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faXNOZWdvdGlhdGluZyA9IHRydWVcbiAgfVxuXG4gIC8vIFRPRE86IERlbGV0ZSB0aGlzIG1ldGhvZCBvbmNlIHJlYWRhYmxlLXN0cmVhbSBpcyB1cGRhdGVkIHRvIGNvbnRhaW4gYSBkZWZhdWx0XG4gIC8vIGltcGxlbWVudGF0aW9uIG9mIGRlc3Ryb3koKSB0aGF0IGF1dG9tYXRpY2FsbHkgY2FsbHMgX2Rlc3Ryb3koKVxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvcmVhZGFibGUtc3RyZWFtL2lzc3Vlcy8yODNcbiAgZGVzdHJveSAoZXJyKSB7XG4gICAgdGhpcy5fZGVzdHJveShlcnIsICgpID0+IHt9KVxuICB9XG5cbiAgX2Rlc3Ryb3kgKGVyciwgY2IpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQgfHwgdGhpcy5kZXN0cm95aW5nKSByZXR1cm5cbiAgICB0aGlzLmRlc3Ryb3lpbmcgPSB0cnVlXG5cbiAgICB0aGlzLl9kZWJ1ZygnZGVzdHJveWluZyAoZXJyb3I6ICVzKScsIGVyciAmJiAoZXJyLm1lc3NhZ2UgfHwgZXJyKSlcblxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHsgLy8gYWxsb3cgZXZlbnRzIGNvbmN1cnJlbnQgd2l0aCB0aGUgY2FsbCB0byBfZGVzdHJveSgpIHRvIGZpcmUgKHNlZSAjNjkyKVxuICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG4gICAgICB0aGlzLmRlc3Ryb3lpbmcgPSBmYWxzZVxuXG4gICAgICB0aGlzLl9kZWJ1ZygnZGVzdHJveSAoZXJyb3I6ICVzKScsIGVyciAmJiAoZXJyLm1lc3NhZ2UgfHwgZXJyKSlcblxuICAgICAgdGhpcy5yZWFkYWJsZSA9IHRoaXMud3JpdGFibGUgPSBmYWxzZVxuXG4gICAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQpIHRoaXMucHVzaChudWxsKVxuICAgICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSB0aGlzLmVuZCgpXG5cbiAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgICB0aGlzLl9wY1JlYWR5ID0gZmFsc2VcbiAgICAgIHRoaXMuX2NoYW5uZWxSZWFkeSA9IGZhbHNlXG4gICAgICB0aGlzLl9yZW1vdGVUcmFja3MgPSBudWxsXG4gICAgICB0aGlzLl9yZW1vdGVTdHJlYW1zID0gbnVsbFxuICAgICAgdGhpcy5fc2VuZGVyTWFwID0gbnVsbFxuXG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX2Nsb3NpbmdJbnRlcnZhbClcbiAgICAgIHRoaXMuX2Nsb3NpbmdJbnRlcnZhbCA9IG51bGxcblxuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbClcbiAgICAgIHRoaXMuX2ludGVydmFsID0gbnVsbFxuICAgICAgdGhpcy5fY2h1bmsgPSBudWxsXG4gICAgICB0aGlzLl9jYiA9IG51bGxcblxuICAgICAgaWYgKHRoaXMuX29uRmluaXNoQm91bmQpIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIHRoaXMuX29uRmluaXNoQm91bmQpXG4gICAgICB0aGlzLl9vbkZpbmlzaEJvdW5kID0gbnVsbFxuXG4gICAgICBpZiAodGhpcy5fY2hhbm5lbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuX2NoYW5uZWwuY2xvc2UoKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgICAgICAgLy8gYWxsb3cgZXZlbnRzIGNvbmN1cnJlbnQgd2l0aCBkZXN0cnVjdGlvbiB0byBiZSBoYW5kbGVkXG4gICAgICAgIHRoaXMuX2NoYW5uZWwub25tZXNzYWdlID0gbnVsbFxuICAgICAgICB0aGlzLl9jaGFubmVsLm9ub3BlbiA9IG51bGxcbiAgICAgICAgdGhpcy5fY2hhbm5lbC5vbmNsb3NlID0gbnVsbFxuICAgICAgICB0aGlzLl9jaGFubmVsLm9uZXJyb3IgPSBudWxsXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fcGMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLl9wYy5jbG9zZSgpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge31cblxuICAgICAgICAvLyBhbGxvdyBldmVudHMgY29uY3VycmVudCB3aXRoIGRlc3RydWN0aW9uIHRvIGJlIGhhbmRsZWRcbiAgICAgICAgdGhpcy5fcGMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBudWxsXG4gICAgICAgIHRoaXMuX3BjLm9uaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UgPSBudWxsXG4gICAgICAgIHRoaXMuX3BjLm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2UgPSBudWxsXG4gICAgICAgIHRoaXMuX3BjLm9uaWNlY2FuZGlkYXRlID0gbnVsbFxuICAgICAgICB0aGlzLl9wYy5vbnRyYWNrID0gbnVsbFxuICAgICAgICB0aGlzLl9wYy5vbmRhdGFjaGFubmVsID0gbnVsbFxuICAgICAgfVxuICAgICAgdGhpcy5fcGMgPSBudWxsXG4gICAgICB0aGlzLl9jaGFubmVsID0gbnVsbFxuXG4gICAgICBpZiAoZXJyKSB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgICAgdGhpcy5lbWl0KCdjbG9zZScpXG4gICAgICBjYigpXG4gICAgfSlcbiAgfVxuXG4gIF9zZXR1cERhdGEgKGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC5jaGFubmVsKSB7XG4gICAgICAvLyBJbiBzb21lIHNpdHVhdGlvbnMgYHBjLmNyZWF0ZURhdGFDaGFubmVsKClgIHJldHVybnMgYHVuZGVmaW5lZGAgKGluIHdydGMpLFxuICAgICAgLy8gd2hpY2ggaXMgaW52YWxpZCBiZWhhdmlvci4gSGFuZGxlIGl0IGdyYWNlZnVsbHkuXG4gICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3Mvc2ltcGxlLXBlZXIvaXNzdWVzLzE2M1xuICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveShlcnJDb2RlKG5ldyBFcnJvcignRGF0YSBjaGFubmVsIGV2ZW50IGlzIG1pc3NpbmcgYGNoYW5uZWxgIHByb3BlcnR5JyksICdFUlJfREFUQV9DSEFOTkVMJykpXG4gICAgfVxuXG4gICAgdGhpcy5fY2hhbm5lbCA9IGV2ZW50LmNoYW5uZWxcbiAgICB0aGlzLl9jaGFubmVsLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInXG5cbiAgICBpZiAodHlwZW9mIHRoaXMuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGQgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkID0gTUFYX0JVRkZFUkVEX0FNT1VOVFxuICAgIH1cblxuICAgIHRoaXMuY2hhbm5lbE5hbWUgPSB0aGlzLl9jaGFubmVsLmxhYmVsXG5cbiAgICB0aGlzLl9jaGFubmVsLm9ubWVzc2FnZSA9IGV2ZW50ID0+IHtcbiAgICAgIHRoaXMuX29uQ2hhbm5lbE1lc3NhZ2UoZXZlbnQpXG4gICAgfVxuICAgIHRoaXMuX2NoYW5uZWwub25idWZmZXJlZGFtb3VudGxvdyA9ICgpID0+IHtcbiAgICAgIHRoaXMuX29uQ2hhbm5lbEJ1ZmZlcmVkQW1vdW50TG93KClcbiAgICB9XG4gICAgdGhpcy5fY2hhbm5lbC5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICB0aGlzLl9vbkNoYW5uZWxPcGVuKClcbiAgICB9XG4gICAgdGhpcy5fY2hhbm5lbC5vbmNsb3NlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fb25DaGFubmVsQ2xvc2UoKVxuICAgIH1cbiAgICB0aGlzLl9jaGFubmVsLm9uZXJyb3IgPSBldmVudCA9PiB7XG4gICAgICBjb25zdCBlcnIgPSBldmVudC5lcnJvciBpbnN0YW5jZW9mIEVycm9yXG4gICAgICAgID8gZXZlbnQuZXJyb3JcbiAgICAgICAgOiBuZXcgRXJyb3IoYERhdGFjaGFubmVsIGVycm9yOiAke2V2ZW50Lm1lc3NhZ2V9ICR7ZXZlbnQuZmlsZW5hbWV9OiR7ZXZlbnQubGluZW5vfToke2V2ZW50LmNvbG5vfWApXG4gICAgICB0aGlzLmRlc3Ryb3koZXJyQ29kZShlcnIsICdFUlJfREFUQV9DSEFOTkVMJykpXG4gICAgfVxuXG4gICAgLy8gSEFDSzogQ2hyb21lIHdpbGwgc29tZXRpbWVzIGdldCBzdHVjayBpbiByZWFkeVN0YXRlIFwiY2xvc2luZ1wiLCBsZXQncyBjaGVjayBmb3IgdGhpcyBjb25kaXRpb25cbiAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04ODI3NDNcbiAgICBsZXQgaXNDbG9zaW5nID0gZmFsc2VcbiAgICB0aGlzLl9jbG9zaW5nSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7IC8vIE5vIFwib25jbG9zaW5nXCIgZXZlbnRcbiAgICAgIGlmICh0aGlzLl9jaGFubmVsICYmIHRoaXMuX2NoYW5uZWwucmVhZHlTdGF0ZSA9PT0gJ2Nsb3NpbmcnKSB7XG4gICAgICAgIGlmIChpc0Nsb3NpbmcpIHRoaXMuX29uQ2hhbm5lbENsb3NlKCkgLy8gY2xvc2luZyB0aW1lZCBvdXQ6IGVxdWl2YWxlbnQgdG8gb25jbG9zZSBmaXJpbmdcbiAgICAgICAgaXNDbG9zaW5nID0gdHJ1ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNDbG9zaW5nID0gZmFsc2VcbiAgICAgIH1cbiAgICB9LCBDSEFOTkVMX0NMT1NJTkdfVElNRU9VVClcbiAgfVxuXG4gIF9yZWFkICgpIHt9XG5cbiAgX3dyaXRlIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm4gY2IoZXJyQ29kZShuZXcgRXJyb3IoJ2Nhbm5vdCB3cml0ZSBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZCcpLCAnRVJSX0RBVEFfQ0hBTk5FTCcpKVxuXG4gICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5zZW5kKGNodW5rKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlc3Ryb3koZXJyQ29kZShlcnIsICdFUlJfREFUQV9DSEFOTkVMJykpXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fY2hhbm5lbC5idWZmZXJlZEFtb3VudCA+IE1BWF9CVUZGRVJFRF9BTU9VTlQpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJ3N0YXJ0IGJhY2twcmVzc3VyZTogYnVmZmVyZWRBbW91bnQgJWQnLCB0aGlzLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50KVxuICAgICAgICB0aGlzLl9jYiA9IGNiXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYihudWxsKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kZWJ1Zygnd3JpdGUgYmVmb3JlIGNvbm5lY3QnKVxuICAgICAgdGhpcy5fY2h1bmsgPSBjaHVua1xuICAgICAgdGhpcy5fY2IgPSBjYlxuICAgIH1cbiAgfVxuXG4gIC8vIFdoZW4gc3RyZWFtIGZpbmlzaGVzIHdyaXRpbmcsIGNsb3NlIHNvY2tldC4gSGFsZiBvcGVuIGNvbm5lY3Rpb25zIGFyZSBub3RcbiAgLy8gc3VwcG9ydGVkLlxuICBfb25GaW5pc2ggKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgICAvLyBXYWl0IGEgYml0IGJlZm9yZSBkZXN0cm95aW5nIHNvIHRoZSBzb2NrZXQgZmx1c2hlcy5cbiAgICAvLyBUT0RPOiBpcyB0aGVyZSBhIG1vcmUgcmVsaWFibGUgd2F5IHRvIGFjY29tcGxpc2ggdGhpcz9cbiAgICBjb25zdCBkZXN0cm95U29vbiA9ICgpID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5kZXN0cm95KCksIDEwMDApXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgZGVzdHJveVNvb24oKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uY2UoJ2Nvbm5lY3QnLCBkZXN0cm95U29vbilcbiAgICB9XG4gIH1cblxuICBfc3RhcnRJY2VDb21wbGV0ZVRpbWVvdXQgKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgaWYgKHRoaXMuX2ljZUNvbXBsZXRlVGltZXIpIHJldHVyblxuICAgIHRoaXMuX2RlYnVnKCdzdGFydGVkIGljZUNvbXBsZXRlIHRpbWVvdXQnKVxuICAgIHRoaXMuX2ljZUNvbXBsZXRlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICghdGhpcy5faWNlQ29tcGxldGUpIHtcbiAgICAgICAgdGhpcy5faWNlQ29tcGxldGUgPSB0cnVlXG4gICAgICAgIHRoaXMuX2RlYnVnKCdpY2VDb21wbGV0ZSB0aW1lb3V0IGNvbXBsZXRlZCcpXG4gICAgICAgIHRoaXMuZW1pdCgnaWNlVGltZW91dCcpXG4gICAgICAgIHRoaXMuZW1pdCgnX2ljZUNvbXBsZXRlJylcbiAgICAgIH1cbiAgICB9LCB0aGlzLmljZUNvbXBsZXRlVGltZW91dClcbiAgfVxuXG4gIF9jcmVhdGVPZmZlciAoKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cblxuICAgIHRoaXMuX3BjLmNyZWF0ZU9mZmVyKHRoaXMub2ZmZXJPcHRpb25zKVxuICAgICAgLnRoZW4ob2ZmZXIgPT4ge1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgICAgICBpZiAoIXRoaXMudHJpY2tsZSAmJiAhdGhpcy5hbGxvd0hhbGZUcmlja2xlKSBvZmZlci5zZHAgPSBmaWx0ZXJUcmlja2xlKG9mZmVyLnNkcClcbiAgICAgICAgb2ZmZXIuc2RwID0gdGhpcy5zZHBUcmFuc2Zvcm0ob2ZmZXIuc2RwKVxuXG4gICAgICAgIGNvbnN0IHNlbmRPZmZlciA9ICgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgICAgICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24gfHwgb2ZmZXJcbiAgICAgICAgICB0aGlzLl9kZWJ1Zygnc2lnbmFsJylcbiAgICAgICAgICB0aGlzLmVtaXQoJ3NpZ25hbCcsIHtcbiAgICAgICAgICAgIHR5cGU6IHNpZ25hbC50eXBlLFxuICAgICAgICAgICAgc2RwOiBzaWduYWwuc2RwXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9uU3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLl9kZWJ1ZygnY3JlYXRlT2ZmZXIgc3VjY2VzcycpXG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgICAgICAgICBpZiAodGhpcy50cmlja2xlIHx8IHRoaXMuX2ljZUNvbXBsZXRlKSBzZW5kT2ZmZXIoKVxuICAgICAgICAgIGVsc2UgdGhpcy5vbmNlKCdfaWNlQ29tcGxldGUnLCBzZW5kT2ZmZXIpIC8vIHdhaXQgZm9yIGNhbmRpZGF0ZXNcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9uRXJyb3IgPSBlcnIgPT4ge1xuICAgICAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKGVyciwgJ0VSUl9TRVRfTE9DQUxfREVTQ1JJUFRJT04nKSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpXG4gICAgICAgICAgLnRoZW4ob25TdWNjZXNzKVxuICAgICAgICAgIC5jYXRjaChvbkVycm9yKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICB0aGlzLmRlc3Ryb3koZXJyQ29kZShlcnIsICdFUlJfQ1JFQVRFX09GRkVSJykpXG4gICAgICB9KVxuICB9XG5cbiAgX3JlcXVlc3RNaXNzaW5nVHJhbnNjZWl2ZXJzICgpIHtcbiAgICBpZiAodGhpcy5fcGMuZ2V0VHJhbnNjZWl2ZXJzKSB7XG4gICAgICB0aGlzLl9wYy5nZXRUcmFuc2NlaXZlcnMoKS5mb3JFYWNoKHRyYW5zY2VpdmVyID0+IHtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlci5taWQgJiYgdHJhbnNjZWl2ZXIuc2VuZGVyLnRyYWNrICYmICF0cmFuc2NlaXZlci5yZXF1ZXN0ZWQpIHtcbiAgICAgICAgICB0cmFuc2NlaXZlci5yZXF1ZXN0ZWQgPSB0cnVlIC8vIEhBQ0s6IFNhZmFyaSByZXR1cm5zIG5lZ290aWF0ZWQgdHJhbnNjZWl2ZXJzIHdpdGggYSBudWxsIG1pZFxuICAgICAgICAgIHRoaXMuYWRkVHJhbnNjZWl2ZXIodHJhbnNjZWl2ZXIuc2VuZGVyLnRyYWNrLmtpbmQpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZUFuc3dlciAoKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cblxuICAgIHRoaXMuX3BjLmNyZWF0ZUFuc3dlcih0aGlzLmFuc3dlck9wdGlvbnMpXG4gICAgICAudGhlbihhbnN3ZXIgPT4ge1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgICAgICBpZiAoIXRoaXMudHJpY2tsZSAmJiAhdGhpcy5hbGxvd0hhbGZUcmlja2xlKSBhbnN3ZXIuc2RwID0gZmlsdGVyVHJpY2tsZShhbnN3ZXIuc2RwKVxuICAgICAgICBhbnN3ZXIuc2RwID0gdGhpcy5zZHBUcmFuc2Zvcm0oYW5zd2VyLnNkcClcblxuICAgICAgICBjb25zdCBzZW5kQW5zd2VyID0gKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgICAgICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbiB8fCBhbnN3ZXJcbiAgICAgICAgICB0aGlzLl9kZWJ1Zygnc2lnbmFsJylcbiAgICAgICAgICB0aGlzLmVtaXQoJ3NpZ25hbCcsIHtcbiAgICAgICAgICAgIHR5cGU6IHNpZ25hbC50eXBlLFxuICAgICAgICAgICAgc2RwOiBzaWduYWwuc2RwXG4gICAgICAgICAgfSlcbiAgICAgICAgICBpZiAoIXRoaXMuaW5pdGlhdG9yKSB0aGlzLl9yZXF1ZXN0TWlzc2luZ1RyYW5zY2VpdmVycygpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvblN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgICAgICAgICBpZiAodGhpcy50cmlja2xlIHx8IHRoaXMuX2ljZUNvbXBsZXRlKSBzZW5kQW5zd2VyKClcbiAgICAgICAgICBlbHNlIHRoaXMub25jZSgnX2ljZUNvbXBsZXRlJywgc2VuZEFuc3dlcilcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9uRXJyb3IgPSBlcnIgPT4ge1xuICAgICAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKGVyciwgJ0VSUl9TRVRfTE9DQUxfREVTQ1JJUFRJT04nKSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKVxuICAgICAgICAgIC50aGVuKG9uU3VjY2VzcylcbiAgICAgICAgICAuY2F0Y2gob25FcnJvcilcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUoZXJyLCAnRVJSX0NSRUFURV9BTlNXRVInKSlcbiAgICAgIH0pXG4gIH1cblxuICBfb25Db25uZWN0aW9uU3RhdGVDaGFuZ2UgKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgaWYgKHRoaXMuX3BjLmNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKG5ldyBFcnJvcignQ29ubmVjdGlvbiBmYWlsZWQuJyksICdFUlJfQ09OTkVDVElPTl9GQUlMVVJFJykpXG4gICAgfVxuICB9XG5cbiAgX29uSWNlU3RhdGVDaGFuZ2UgKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgY29uc3QgaWNlQ29ubmVjdGlvblN0YXRlID0gdGhpcy5fcGMuaWNlQ29ubmVjdGlvblN0YXRlXG4gICAgY29uc3QgaWNlR2F0aGVyaW5nU3RhdGUgPSB0aGlzLl9wYy5pY2VHYXRoZXJpbmdTdGF0ZVxuXG4gICAgdGhpcy5fZGVidWcoXG4gICAgICAnaWNlU3RhdGVDaGFuZ2UgKGNvbm5lY3Rpb246ICVzKSAoZ2F0aGVyaW5nOiAlcyknLFxuICAgICAgaWNlQ29ubmVjdGlvblN0YXRlLFxuICAgICAgaWNlR2F0aGVyaW5nU3RhdGVcbiAgICApXG4gICAgdGhpcy5lbWl0KCdpY2VTdGF0ZUNoYW5nZScsIGljZUNvbm5lY3Rpb25TdGF0ZSwgaWNlR2F0aGVyaW5nU3RhdGUpXG5cbiAgICBpZiAoaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGVkJyB8fCBpY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjb21wbGV0ZWQnKSB7XG4gICAgICB0aGlzLl9wY1JlYWR5ID0gdHJ1ZVxuICAgICAgdGhpcy5fbWF5YmVSZWFkeSgpXG4gICAgfVxuICAgIGlmIChpY2VDb25uZWN0aW9uU3RhdGUgPT09ICdmYWlsZWQnKSB7XG4gICAgICB0aGlzLmRlc3Ryb3koZXJyQ29kZShuZXcgRXJyb3IoJ0ljZSBjb25uZWN0aW9uIGZhaWxlZC4nKSwgJ0VSUl9JQ0VfQ09OTkVDVElPTl9GQUlMVVJFJykpXG4gICAgfVxuICAgIGlmIChpY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICB0aGlzLmRlc3Ryb3koZXJyQ29kZShuZXcgRXJyb3IoJ0ljZSBjb25uZWN0aW9uIGNsb3NlZC4nKSwgJ0VSUl9JQ0VfQ09OTkVDVElPTl9DTE9TRUQnKSlcbiAgICB9XG4gIH1cblxuICBnZXRTdGF0cyAoY2IpIHtcbiAgICAvLyBzdGF0cmVwb3J0cyBjYW4gY29tZSB3aXRoIGEgdmFsdWUgYXJyYXkgaW5zdGVhZCBvZiBwcm9wZXJ0aWVzXG4gICAgY29uc3QgZmxhdHRlblZhbHVlcyA9IHJlcG9ydCA9PiB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHJlcG9ydC52YWx1ZXMpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgIHJlcG9ydC52YWx1ZXMuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXBvcnQsIHZhbHVlKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcG9ydFxuICAgIH1cblxuICAgIC8vIFByb21pc2UtYmFzZWQgZ2V0U3RhdHMoKSAoc3RhbmRhcmQpXG4gICAgaWYgKHRoaXMuX3BjLmdldFN0YXRzLmxlbmd0aCA9PT0gMCB8fCB0aGlzLl9pc1JlYWN0TmF0aXZlV2VicnRjKSB7XG4gICAgICB0aGlzLl9wYy5nZXRTdGF0cygpXG4gICAgICAgIC50aGVuKHJlcyA9PiB7XG4gICAgICAgICAgY29uc3QgcmVwb3J0cyA9IFtdXG4gICAgICAgICAgcmVzLmZvckVhY2gocmVwb3J0ID0+IHtcbiAgICAgICAgICAgIHJlcG9ydHMucHVzaChmbGF0dGVuVmFsdWVzKHJlcG9ydCkpXG4gICAgICAgICAgfSlcbiAgICAgICAgICBjYihudWxsLCByZXBvcnRzKVxuICAgICAgICB9LCBlcnIgPT4gY2IoZXJyKSlcblxuICAgIC8vIFNpbmdsZS1wYXJhbWV0ZXIgY2FsbGJhY2stYmFzZWQgZ2V0U3RhdHMoKSAobm9uLXN0YW5kYXJkKVxuICAgIH0gZWxzZSBpZiAodGhpcy5fcGMuZ2V0U3RhdHMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5fcGMuZ2V0U3RhdHMocmVzID0+IHtcbiAgICAgICAgLy8gSWYgd2UgZGVzdHJveSBjb25uZWN0aW9uIGluIGBjb25uZWN0YCBjYWxsYmFjayB0aGlzIGNvZGUgbWlnaHQgaGFwcGVuIHRvIHJ1biB3aGVuIGFjdHVhbCBjb25uZWN0aW9uIGlzIGFscmVhZHkgY2xvc2VkXG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgICAgICAgY29uc3QgcmVwb3J0cyA9IFtdXG4gICAgICAgIHJlcy5yZXN1bHQoKS5mb3JFYWNoKHJlc3VsdCA9PiB7XG4gICAgICAgICAgY29uc3QgcmVwb3J0ID0ge31cbiAgICAgICAgICByZXN1bHQubmFtZXMoKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgICAgcmVwb3J0W25hbWVdID0gcmVzdWx0LnN0YXQobmFtZSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIHJlcG9ydC5pZCA9IHJlc3VsdC5pZFxuICAgICAgICAgIHJlcG9ydC50eXBlID0gcmVzdWx0LnR5cGVcbiAgICAgICAgICByZXBvcnQudGltZXN0YW1wID0gcmVzdWx0LnRpbWVzdGFtcFxuICAgICAgICAgIHJlcG9ydHMucHVzaChmbGF0dGVuVmFsdWVzKHJlcG9ydCkpXG4gICAgICAgIH0pXG4gICAgICAgIGNiKG51bGwsIHJlcG9ydHMpXG4gICAgICB9LCBlcnIgPT4gY2IoZXJyKSlcblxuICAgIC8vIFVua25vd24gYnJvd3Nlciwgc2tpcCBnZXRTdGF0cygpIHNpbmNlIGl0J3MgYW55b25lJ3MgZ3Vlc3Mgd2hpY2ggc3R5bGUgb2ZcbiAgICAvLyBnZXRTdGF0cygpIHRoZXkgaW1wbGVtZW50LlxuICAgIH0gZWxzZSB7XG4gICAgICBjYihudWxsLCBbXSlcbiAgICB9XG4gIH1cblxuICBfbWF5YmVSZWFkeSAoKSB7XG4gICAgdGhpcy5fZGVidWcoJ21heWJlUmVhZHkgcGMgJXMgY2hhbm5lbCAlcycsIHRoaXMuX3BjUmVhZHksIHRoaXMuX2NoYW5uZWxSZWFkeSlcbiAgICBpZiAodGhpcy5fY29ubmVjdGVkIHx8IHRoaXMuX2Nvbm5lY3RpbmcgfHwgIXRoaXMuX3BjUmVhZHkgfHwgIXRoaXMuX2NoYW5uZWxSZWFkeSkgcmV0dXJuXG5cbiAgICB0aGlzLl9jb25uZWN0aW5nID0gdHJ1ZVxuXG4gICAgLy8gSEFDSzogV2UgY2FuJ3QgcmVseSBvbiBvcmRlciBoZXJlLCBmb3IgZGV0YWlscyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pzLXBsYXRmb3JtL25vZGUtd2VicnRjL2lzc3Vlcy8zMzlcbiAgICBjb25zdCBmaW5kQ2FuZGlkYXRlUGFpciA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgICAgIHRoaXMuZ2V0U3RhdHMoKGVyciwgaXRlbXMpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cblxuICAgICAgICAvLyBUcmVhdCBnZXRTdGF0cyBlcnJvciBhcyBub24tZmF0YWwuIEl0J3Mgbm90IGVzc2VudGlhbC5cbiAgICAgICAgaWYgKGVycikgaXRlbXMgPSBbXVxuXG4gICAgICAgIGNvbnN0IHJlbW90ZUNhbmRpZGF0ZXMgPSB7fVxuICAgICAgICBjb25zdCBsb2NhbENhbmRpZGF0ZXMgPSB7fVxuICAgICAgICBjb25zdCBjYW5kaWRhdGVQYWlycyA9IHt9XG4gICAgICAgIGxldCBmb3VuZFNlbGVjdGVkQ2FuZGlkYXRlUGFpciA9IGZhbHNlXG5cbiAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAvLyBUT0RPOiBPbmNlIGFsbCBicm93c2VycyBzdXBwb3J0IHRoZSBoeXBoZW5hdGVkIHN0YXRzIHJlcG9ydCB0eXBlcywgcmVtb3ZlXG4gICAgICAgICAgLy8gdGhlIG5vbi1oeXBlbmF0ZWQgb25lc1xuICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT09ICdyZW1vdGVjYW5kaWRhdGUnIHx8IGl0ZW0udHlwZSA9PT0gJ3JlbW90ZS1jYW5kaWRhdGUnKSB7XG4gICAgICAgICAgICByZW1vdGVDYW5kaWRhdGVzW2l0ZW0uaWRdID0gaXRlbVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSAnbG9jYWxjYW5kaWRhdGUnIHx8IGl0ZW0udHlwZSA9PT0gJ2xvY2FsLWNhbmRpZGF0ZScpIHtcbiAgICAgICAgICAgIGxvY2FsQ2FuZGlkYXRlc1tpdGVtLmlkXSA9IGl0ZW1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ2NhbmRpZGF0ZXBhaXInIHx8IGl0ZW0udHlwZSA9PT0gJ2NhbmRpZGF0ZS1wYWlyJykge1xuICAgICAgICAgICAgY2FuZGlkYXRlUGFpcnNbaXRlbS5pZF0gPSBpdGVtXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN0IHNldFNlbGVjdGVkQ2FuZGlkYXRlUGFpciA9IHNlbGVjdGVkQ2FuZGlkYXRlUGFpciA9PiB7XG4gICAgICAgICAgZm91bmRTZWxlY3RlZENhbmRpZGF0ZVBhaXIgPSB0cnVlXG5cbiAgICAgICAgICBsZXQgbG9jYWwgPSBsb2NhbENhbmRpZGF0ZXNbc2VsZWN0ZWRDYW5kaWRhdGVQYWlyLmxvY2FsQ2FuZGlkYXRlSWRdXG5cbiAgICAgICAgICBpZiAobG9jYWwgJiYgKGxvY2FsLmlwIHx8IGxvY2FsLmFkZHJlc3MpKSB7XG4gICAgICAgICAgICAvLyBTcGVjXG4gICAgICAgICAgICB0aGlzLmxvY2FsQWRkcmVzcyA9IGxvY2FsLmlwIHx8IGxvY2FsLmFkZHJlc3NcbiAgICAgICAgICAgIHRoaXMubG9jYWxQb3J0ID0gTnVtYmVyKGxvY2FsLnBvcnQpXG4gICAgICAgICAgfSBlbHNlIGlmIChsb2NhbCAmJiBsb2NhbC5pcEFkZHJlc3MpIHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3hcbiAgICAgICAgICAgIHRoaXMubG9jYWxBZGRyZXNzID0gbG9jYWwuaXBBZGRyZXNzXG4gICAgICAgICAgICB0aGlzLmxvY2FsUG9ydCA9IE51bWJlcihsb2NhbC5wb3J0TnVtYmVyKVxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGVjdGVkQ2FuZGlkYXRlUGFpci5nb29nTG9jYWxBZGRyZXNzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgb25jZSBDaHJvbWUgNTggaXMgcmVsZWFzZWRcbiAgICAgICAgICAgIGxvY2FsID0gc2VsZWN0ZWRDYW5kaWRhdGVQYWlyLmdvb2dMb2NhbEFkZHJlc3Muc3BsaXQoJzonKVxuICAgICAgICAgICAgdGhpcy5sb2NhbEFkZHJlc3MgPSBsb2NhbFswXVxuICAgICAgICAgICAgdGhpcy5sb2NhbFBvcnQgPSBOdW1iZXIobG9jYWxbMV0pXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmxvY2FsQWRkcmVzcykge1xuICAgICAgICAgICAgdGhpcy5sb2NhbEZhbWlseSA9IHRoaXMubG9jYWxBZGRyZXNzLmluY2x1ZGVzKCc6JykgPyAnSVB2NicgOiAnSVB2NCdcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgcmVtb3RlID0gcmVtb3RlQ2FuZGlkYXRlc1tzZWxlY3RlZENhbmRpZGF0ZVBhaXIucmVtb3RlQ2FuZGlkYXRlSWRdXG5cbiAgICAgICAgICBpZiAocmVtb3RlICYmIChyZW1vdGUuaXAgfHwgcmVtb3RlLmFkZHJlc3MpKSB7XG4gICAgICAgICAgICAvLyBTcGVjXG4gICAgICAgICAgICB0aGlzLnJlbW90ZUFkZHJlc3MgPSByZW1vdGUuaXAgfHwgcmVtb3RlLmFkZHJlc3NcbiAgICAgICAgICAgIHRoaXMucmVtb3RlUG9ydCA9IE51bWJlcihyZW1vdGUucG9ydClcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlbW90ZSAmJiByZW1vdGUuaXBBZGRyZXNzKSB7XG4gICAgICAgICAgICAvLyBGaXJlZm94XG4gICAgICAgICAgICB0aGlzLnJlbW90ZUFkZHJlc3MgPSByZW1vdGUuaXBBZGRyZXNzXG4gICAgICAgICAgICB0aGlzLnJlbW90ZVBvcnQgPSBOdW1iZXIocmVtb3RlLnBvcnROdW1iZXIpXG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZWN0ZWRDYW5kaWRhdGVQYWlyLmdvb2dSZW1vdGVBZGRyZXNzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgb25jZSBDaHJvbWUgNTggaXMgcmVsZWFzZWRcbiAgICAgICAgICAgIHJlbW90ZSA9IHNlbGVjdGVkQ2FuZGlkYXRlUGFpci5nb29nUmVtb3RlQWRkcmVzcy5zcGxpdCgnOicpXG4gICAgICAgICAgICB0aGlzLnJlbW90ZUFkZHJlc3MgPSByZW1vdGVbMF1cbiAgICAgICAgICAgIHRoaXMucmVtb3RlUG9ydCA9IE51bWJlcihyZW1vdGVbMV0pXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLnJlbW90ZUFkZHJlc3MpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3RlRmFtaWx5ID0gdGhpcy5yZW1vdGVBZGRyZXNzLmluY2x1ZGVzKCc6JykgPyAnSVB2NicgOiAnSVB2NCdcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9kZWJ1ZyhcbiAgICAgICAgICAgICdjb25uZWN0IGxvY2FsOiAlczolcyByZW1vdGU6ICVzOiVzJyxcbiAgICAgICAgICAgIHRoaXMubG9jYWxBZGRyZXNzLFxuICAgICAgICAgICAgdGhpcy5sb2NhbFBvcnQsXG4gICAgICAgICAgICB0aGlzLnJlbW90ZUFkZHJlc3MsXG4gICAgICAgICAgICB0aGlzLnJlbW90ZVBvcnRcbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgIC8vIFNwZWMtY29tcGxpYW50XG4gICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ3RyYW5zcG9ydCcgJiYgaXRlbS5zZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCkge1xuICAgICAgICAgICAgc2V0U2VsZWN0ZWRDYW5kaWRhdGVQYWlyKGNhbmRpZGF0ZVBhaXJzW2l0ZW0uc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWRdKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE9sZCBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoaXRlbS50eXBlID09PSAnZ29vZ0NhbmRpZGF0ZVBhaXInICYmIGl0ZW0uZ29vZ0FjdGl2ZUNvbm5lY3Rpb24gPT09ICd0cnVlJykgfHxcbiAgICAgICAgICAgICgoaXRlbS50eXBlID09PSAnY2FuZGlkYXRlcGFpcicgfHwgaXRlbS50eXBlID09PSAnY2FuZGlkYXRlLXBhaXInKSAmJiBpdGVtLnNlbGVjdGVkKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgc2V0U2VsZWN0ZWRDYW5kaWRhdGVQYWlyKGl0ZW0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIElnbm9yZSBjYW5kaWRhdGUgcGFpciBzZWxlY3Rpb24gaW4gYnJvd3NlcnMgbGlrZSBTYWZhcmkgMTEgdGhhdCBkbyBub3QgaGF2ZSBhbnkgbG9jYWwgb3IgcmVtb3RlIGNhbmRpZGF0ZXNcbiAgICAgICAgLy8gQnV0IHdhaXQgdW50aWwgYXQgbGVhc3QgMSBjYW5kaWRhdGUgcGFpciBpcyBhdmFpbGFibGVcbiAgICAgICAgaWYgKCFmb3VuZFNlbGVjdGVkQ2FuZGlkYXRlUGFpciAmJiAoIU9iamVjdC5rZXlzKGNhbmRpZGF0ZVBhaXJzKS5sZW5ndGggfHwgT2JqZWN0LmtleXMobG9jYWxDYW5kaWRhdGVzKS5sZW5ndGgpKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmaW5kQ2FuZGlkYXRlUGFpciwgMTAwKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2Nvbm5lY3RpbmcgPSBmYWxzZVxuICAgICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9jaHVuaykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnNlbmQodGhpcy5fY2h1bmspXG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXN0cm95KGVyckNvZGUoZXJyLCAnRVJSX0RBVEFfQ0hBTk5FTCcpKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9jaHVuayA9IG51bGxcbiAgICAgICAgICB0aGlzLl9kZWJ1Zygnc2VudCBjaHVuayBmcm9tIFwid3JpdGUgYmVmb3JlIGNvbm5lY3RcIicpXG5cbiAgICAgICAgICBjb25zdCBjYiA9IHRoaXMuX2NiXG4gICAgICAgICAgdGhpcy5fY2IgPSBudWxsXG4gICAgICAgICAgY2IobnVsbClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGBidWZmZXJlZEFtb3VudExvd1RocmVzaG9sZGAgYW5kICdvbmJ1ZmZlcmVkYW1vdW50bG93JyBhcmUgdW5zdXBwb3J0ZWQsXG4gICAgICAgIC8vIGZhbGxiYWNrIHRvIHVzaW5nIHNldEludGVydmFsIHRvIGltcGxlbWVudCBiYWNrcHJlc3N1cmUuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fY2hhbm5lbC5idWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHRoaXMuX29uSW50ZXJ2YWwoKSwgMTUwKVxuICAgICAgICAgIGlmICh0aGlzLl9pbnRlcnZhbC51bnJlZikgdGhpcy5faW50ZXJ2YWwudW5yZWYoKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZGVidWcoJ2Nvbm5lY3QnKVxuICAgICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3QnKVxuICAgICAgfSlcbiAgICB9XG4gICAgZmluZENhbmRpZGF0ZVBhaXIoKVxuICB9XG5cbiAgX29uSW50ZXJ2YWwgKCkge1xuICAgIGlmICghdGhpcy5fY2IgfHwgIXRoaXMuX2NoYW5uZWwgfHwgdGhpcy5fY2hhbm5lbC5idWZmZXJlZEFtb3VudCA+IE1BWF9CVUZGRVJFRF9BTU9VTlQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLl9vbkNoYW5uZWxCdWZmZXJlZEFtb3VudExvdygpXG4gIH1cblxuICBfb25TaWduYWxpbmdTdGF0ZUNoYW5nZSAoKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cblxuICAgIGlmICh0aGlzLl9wYy5zaWduYWxpbmdTdGF0ZSA9PT0gJ3N0YWJsZScpIHtcbiAgICAgIHRoaXMuX2lzTmVnb3RpYXRpbmcgPSBmYWxzZVxuXG4gICAgICAvLyBIQUNLOiBGaXJlZm94IGRvZXNuJ3QgeWV0IHN1cHBvcnQgcmVtb3ZpbmcgdHJhY2tzIHdoZW4gc2lnbmFsaW5nU3RhdGUgIT09ICdzdGFibGUnXG4gICAgICB0aGlzLl9kZWJ1ZygnZmx1c2hpbmcgc2VuZGVyIHF1ZXVlJywgdGhpcy5fc2VuZGVyc0F3YWl0aW5nU3RhYmxlKVxuICAgICAgdGhpcy5fc2VuZGVyc0F3YWl0aW5nU3RhYmxlLmZvckVhY2goc2VuZGVyID0+IHtcbiAgICAgICAgdGhpcy5fcGMucmVtb3ZlVHJhY2soc2VuZGVyKVxuICAgICAgICB0aGlzLl9xdWV1ZWROZWdvdGlhdGlvbiA9IHRydWVcbiAgICAgIH0pXG4gICAgICB0aGlzLl9zZW5kZXJzQXdhaXRpbmdTdGFibGUgPSBbXVxuXG4gICAgICBpZiAodGhpcy5fcXVldWVkTmVnb3RpYXRpb24pIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJ2ZsdXNoaW5nIG5lZ290aWF0aW9uIHF1ZXVlJylcbiAgICAgICAgdGhpcy5fcXVldWVkTmVnb3RpYXRpb24gPSBmYWxzZVxuICAgICAgICB0aGlzLl9uZWVkc05lZ290aWF0aW9uKCkgLy8gbmVnb3RpYXRlIGFnYWluXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnbmVnb3RpYXRlZCcpXG4gICAgICAgIHRoaXMuZW1pdCgnbmVnb3RpYXRlZCcpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fZGVidWcoJ3NpZ25hbGluZ1N0YXRlQ2hhbmdlICVzJywgdGhpcy5fcGMuc2lnbmFsaW5nU3RhdGUpXG4gICAgdGhpcy5lbWl0KCdzaWduYWxpbmdTdGF0ZUNoYW5nZScsIHRoaXMuX3BjLnNpZ25hbGluZ1N0YXRlKVxuICB9XG5cbiAgX29uSWNlQ2FuZGlkYXRlIChldmVudCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgaWYgKGV2ZW50LmNhbmRpZGF0ZSAmJiB0aGlzLnRyaWNrbGUpIHtcbiAgICAgIHRoaXMuZW1pdCgnc2lnbmFsJywge1xuICAgICAgICB0eXBlOiAnY2FuZGlkYXRlJyxcbiAgICAgICAgY2FuZGlkYXRlOiB7XG4gICAgICAgICAgY2FuZGlkYXRlOiBldmVudC5jYW5kaWRhdGUuY2FuZGlkYXRlLFxuICAgICAgICAgIHNkcE1MaW5lSW5kZXg6IGV2ZW50LmNhbmRpZGF0ZS5zZHBNTGluZUluZGV4LFxuICAgICAgICAgIHNkcE1pZDogZXZlbnQuY2FuZGlkYXRlLnNkcE1pZFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAoIWV2ZW50LmNhbmRpZGF0ZSAmJiAhdGhpcy5faWNlQ29tcGxldGUpIHtcbiAgICAgIHRoaXMuX2ljZUNvbXBsZXRlID0gdHJ1ZVxuICAgICAgdGhpcy5lbWl0KCdfaWNlQ29tcGxldGUnKVxuICAgIH1cbiAgICAvLyBhcyBzb29uIGFzIHdlJ3ZlIHJlY2VpdmVkIG9uZSB2YWxpZCBjYW5kaWRhdGUgc3RhcnQgdGltZW91dFxuICAgIGlmIChldmVudC5jYW5kaWRhdGUpIHtcbiAgICAgIHRoaXMuX3N0YXJ0SWNlQ29tcGxldGVUaW1lb3V0KClcbiAgICB9XG4gIH1cblxuICBfb25DaGFubmVsTWVzc2FnZSAoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgIGxldCBkYXRhID0gZXZlbnQuZGF0YVxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKVxuICAgIHRoaXMucHVzaChkYXRhKVxuICB9XG5cbiAgX29uQ2hhbm5lbEJ1ZmZlcmVkQW1vdW50TG93ICgpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQgfHwgIXRoaXMuX2NiKSByZXR1cm5cbiAgICB0aGlzLl9kZWJ1ZygnZW5kaW5nIGJhY2twcmVzc3VyZTogYnVmZmVyZWRBbW91bnQgJWQnLCB0aGlzLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50KVxuICAgIGNvbnN0IGNiID0gdGhpcy5fY2JcbiAgICB0aGlzLl9jYiA9IG51bGxcbiAgICBjYihudWxsKVxuICB9XG5cbiAgX29uQ2hhbm5lbE9wZW4gKCkge1xuICAgIGlmICh0aGlzLl9jb25uZWN0ZWQgfHwgdGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgIHRoaXMuX2RlYnVnKCdvbiBjaGFubmVsIG9wZW4nKVxuICAgIHRoaXMuX2NoYW5uZWxSZWFkeSA9IHRydWVcbiAgICB0aGlzLl9tYXliZVJlYWR5KClcbiAgfVxuXG4gIF9vbkNoYW5uZWxDbG9zZSAoKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgICB0aGlzLl9kZWJ1Zygnb24gY2hhbm5lbCBjbG9zZScpXG4gICAgdGhpcy5kZXN0cm95KClcbiAgfVxuXG4gIF9vblRyYWNrIChldmVudCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgICBldmVudC5zdHJlYW1zLmZvckVhY2goZXZlbnRTdHJlYW0gPT4ge1xuICAgICAgdGhpcy5fZGVidWcoJ29uIHRyYWNrJylcbiAgICAgIHRoaXMuZW1pdCgndHJhY2snLCBldmVudC50cmFjaywgZXZlbnRTdHJlYW0pXG5cbiAgICAgIHRoaXMuX3JlbW90ZVRyYWNrcy5wdXNoKHtcbiAgICAgICAgdHJhY2s6IGV2ZW50LnRyYWNrLFxuICAgICAgICBzdHJlYW06IGV2ZW50U3RyZWFtXG4gICAgICB9KVxuXG4gICAgICBpZiAodGhpcy5fcmVtb3RlU3RyZWFtcy5zb21lKHJlbW90ZVN0cmVhbSA9PiB7XG4gICAgICAgIHJldHVybiByZW1vdGVTdHJlYW0uaWQgPT09IGV2ZW50U3RyZWFtLmlkXG4gICAgICB9KSkgcmV0dXJuIC8vIE9ubHkgZmlyZSBvbmUgJ3N0cmVhbScgZXZlbnQsIGV2ZW4gdGhvdWdoIHRoZXJlIG1heSBiZSBtdWx0aXBsZSB0cmFja3MgcGVyIHN0cmVhbVxuXG4gICAgICB0aGlzLl9yZW1vdGVTdHJlYW1zLnB1c2goZXZlbnRTdHJlYW0pXG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdvbiBzdHJlYW0nKVxuICAgICAgICB0aGlzLmVtaXQoJ3N0cmVhbScsIGV2ZW50U3RyZWFtKSAvLyBlbnN1cmUgYWxsIHRyYWNrcyBoYXZlIGJlZW4gYWRkZWRcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIF9kZWJ1ZyAoKSB7XG4gICAgY29uc3QgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgIGFyZ3NbMF0gPSAnWycgKyB0aGlzLl9pZCArICddICcgKyBhcmdzWzBdXG4gICAgZGVidWcuYXBwbHkobnVsbCwgYXJncylcbiAgfVxufVxuXG5QZWVyLldFQlJUQ19TVVBQT1JUID0gISFnZXRCcm93c2VyUlRDKClcblxuLyoqXG4gKiBFeHBvc2UgcGVlciBhbmQgZGF0YSBjaGFubmVsIGNvbmZpZyBmb3Igb3ZlcnJpZGluZyBhbGwgUGVlclxuICogaW5zdGFuY2VzLiBPdGhlcndpc2UsIGp1c3Qgc2V0IG9wdHMuY29uZmlnIG9yIG9wdHMuY2hhbm5lbENvbmZpZ1xuICogd2hlbiBjb25zdHJ1Y3RpbmcgYSBQZWVyLlxuICovXG5QZWVyLmNvbmZpZyA9IHtcbiAgaWNlU2VydmVyczogW1xuICAgIHtcbiAgICAgIHVybHM6IFtcbiAgICAgICAgJ3N0dW46c3R1bi5sLmdvb2dsZS5jb206MTkzMDInLFxuICAgICAgICAnc3R1bjpnbG9iYWwuc3R1bi50d2lsaW8uY29tOjM0NzgnXG4gICAgICBdXG4gICAgfVxuICBdLFxuICBzZHBTZW1hbnRpY3M6ICd1bmlmaWVkLXBsYW4nXG59XG5cblBlZXIuY2hhbm5lbENvbmZpZyA9IHt9XG5cbm1vZHVsZS5leHBvcnRzID0gUGVlclxuIl0sIm5hbWVzIjpbImRlYnVnIiwicmVxdWlyZSIsImdldEJyb3dzZXJSVEMiLCJyYW5kb21ieXRlcyIsInN0cmVhbSIsInF1ZXVlTWljcm90YXNrIiwiZXJyQ29kZSIsIkJ1ZmZlciIsIk1BWF9CVUZGRVJFRF9BTU9VTlQiLCJJQ0VDT01QTEVURV9USU1FT1VUIiwiQ0hBTk5FTF9DTE9TSU5HX1RJTUVPVVQiLCJmaWx0ZXJUcmlja2xlIiwic2RwIiwicmVwbGFjZSIsIndhcm4iLCJtZXNzYWdlIiwiY29uc29sZSIsIlBlZXIiLCJEdXBsZXgiLCJjb25zdHJ1Y3RvciIsIm9wdHMiLCJPYmplY3QiLCJhc3NpZ24iLCJhbGxvd0hhbGZPcGVuIiwiX2lkIiwidG9TdHJpbmciLCJzbGljZSIsIl9kZWJ1ZyIsImNoYW5uZWxOYW1lIiwiaW5pdGlhdG9yIiwiY2hhbm5lbENvbmZpZyIsImNoYW5uZWxOZWdvdGlhdGVkIiwibmVnb3RpYXRlZCIsImNvbmZpZyIsIm9mZmVyT3B0aW9ucyIsImFuc3dlck9wdGlvbnMiLCJzZHBUcmFuc2Zvcm0iLCJzdHJlYW1zIiwidHJpY2tsZSIsInVuZGVmaW5lZCIsImFsbG93SGFsZlRyaWNrbGUiLCJpY2VDb21wbGV0ZVRpbWVvdXQiLCJkZXN0cm95ZWQiLCJkZXN0cm95aW5nIiwiX2Nvbm5lY3RlZCIsInJlbW90ZUFkZHJlc3MiLCJyZW1vdGVGYW1pbHkiLCJyZW1vdGVQb3J0IiwibG9jYWxBZGRyZXNzIiwibG9jYWxGYW1pbHkiLCJsb2NhbFBvcnQiLCJfd3J0YyIsIndydGMiLCJFcnJvciIsIl9wY1JlYWR5IiwiX2NoYW5uZWxSZWFkeSIsIl9pY2VDb21wbGV0ZSIsIl9pY2VDb21wbGV0ZVRpbWVyIiwiX2NoYW5uZWwiLCJfcGVuZGluZ0NhbmRpZGF0ZXMiLCJfaXNOZWdvdGlhdGluZyIsIl9maXJzdE5lZ290aWF0aW9uIiwiX2JhdGNoZWROZWdvdGlhdGlvbiIsIl9xdWV1ZWROZWdvdGlhdGlvbiIsIl9zZW5kZXJzQXdhaXRpbmdTdGFibGUiLCJfc2VuZGVyTWFwIiwiTWFwIiwiX2Nsb3NpbmdJbnRlcnZhbCIsIl9yZW1vdGVUcmFja3MiLCJfcmVtb3RlU3RyZWFtcyIsIl9jaHVuayIsIl9jYiIsIl9pbnRlcnZhbCIsIl9wYyIsIlJUQ1BlZXJDb25uZWN0aW9uIiwiZXJyIiwiZGVzdHJveSIsIl9pc1JlYWN0TmF0aXZlV2VicnRjIiwiX3BlZXJDb25uZWN0aW9uSWQiLCJvbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSIsIl9vbkljZVN0YXRlQ2hhbmdlIiwib25pY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZSIsIm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlIiwiX29uQ29ubmVjdGlvblN0YXRlQ2hhbmdlIiwib25zaWduYWxpbmdzdGF0ZWNoYW5nZSIsIl9vblNpZ25hbGluZ1N0YXRlQ2hhbmdlIiwib25pY2VjYW5kaWRhdGUiLCJldmVudCIsIl9vbkljZUNhbmRpZGF0ZSIsInBlZXJJZGVudGl0eSIsImNhdGNoIiwiX3NldHVwRGF0YSIsImNoYW5uZWwiLCJjcmVhdGVEYXRhQ2hhbm5lbCIsIm9uZGF0YWNoYW5uZWwiLCJmb3JFYWNoIiwiYWRkU3RyZWFtIiwib250cmFjayIsIl9vblRyYWNrIiwiX25lZWRzTmVnb3RpYXRpb24iLCJfb25GaW5pc2hCb3VuZCIsIl9vbkZpbmlzaCIsIm9uY2UiLCJidWZmZXJTaXplIiwiYnVmZmVyZWRBbW91bnQiLCJjb25uZWN0ZWQiLCJyZWFkeVN0YXRlIiwiYWRkcmVzcyIsInBvcnQiLCJmYW1pbHkiLCJzaWduYWwiLCJkYXRhIiwiSlNPTiIsInBhcnNlIiwicmVuZWdvdGlhdGUiLCJ0cmFuc2NlaXZlclJlcXVlc3QiLCJhZGRUcmFuc2NlaXZlciIsImtpbmQiLCJpbml0IiwiY2FuZGlkYXRlIiwicmVtb3RlRGVzY3JpcHRpb24iLCJ0eXBlIiwiX2FkZEljZUNhbmRpZGF0ZSIsInB1c2giLCJzZXRSZW1vdGVEZXNjcmlwdGlvbiIsIlJUQ1Nlc3Npb25EZXNjcmlwdGlvbiIsInRoZW4iLCJfY3JlYXRlQW5zd2VyIiwiaWNlQ2FuZGlkYXRlT2JqIiwiUlRDSWNlQ2FuZGlkYXRlIiwiYWRkSWNlQ2FuZGlkYXRlIiwiZW5kc1dpdGgiLCJzZW5kIiwiY2h1bmsiLCJlbWl0IiwiZ2V0VHJhY2tzIiwidHJhY2siLCJhZGRUcmFjayIsInN1Ym1hcCIsImdldCIsInNlbmRlciIsInNldCIsInJlbW92ZWQiLCJyZXBsYWNlVHJhY2siLCJvbGRUcmFjayIsIm5ld1RyYWNrIiwicmVtb3ZlVHJhY2siLCJuYW1lIiwicmVtb3ZlU3RyZWFtIiwibmVnb3RpYXRlIiwic2V0VGltZW91dCIsIl9jcmVhdGVPZmZlciIsIl9kZXN0cm95IiwiY2IiLCJyZWFkYWJsZSIsIndyaXRhYmxlIiwiX3JlYWRhYmxlU3RhdGUiLCJlbmRlZCIsIl93cml0YWJsZVN0YXRlIiwiZmluaXNoZWQiLCJlbmQiLCJjbGVhckludGVydmFsIiwicmVtb3ZlTGlzdGVuZXIiLCJjbG9zZSIsIm9ubWVzc2FnZSIsIm9ub3BlbiIsIm9uY2xvc2UiLCJvbmVycm9yIiwiYmluYXJ5VHlwZSIsImJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkIiwibGFiZWwiLCJfb25DaGFubmVsTWVzc2FnZSIsIm9uYnVmZmVyZWRhbW91bnRsb3ciLCJfb25DaGFubmVsQnVmZmVyZWRBbW91bnRMb3ciLCJfb25DaGFubmVsT3BlbiIsIl9vbkNoYW5uZWxDbG9zZSIsImVycm9yIiwiZmlsZW5hbWUiLCJsaW5lbm8iLCJjb2xubyIsImlzQ2xvc2luZyIsInNldEludGVydmFsIiwiX3JlYWQiLCJfd3JpdGUiLCJlbmNvZGluZyIsImRlc3Ryb3lTb29uIiwiX3N0YXJ0SWNlQ29tcGxldGVUaW1lb3V0IiwiY3JlYXRlT2ZmZXIiLCJvZmZlciIsInNlbmRPZmZlciIsImxvY2FsRGVzY3JpcHRpb24iLCJvblN1Y2Nlc3MiLCJvbkVycm9yIiwic2V0TG9jYWxEZXNjcmlwdGlvbiIsIl9yZXF1ZXN0TWlzc2luZ1RyYW5zY2VpdmVycyIsImdldFRyYW5zY2VpdmVycyIsInRyYW5zY2VpdmVyIiwibWlkIiwicmVxdWVzdGVkIiwiY3JlYXRlQW5zd2VyIiwiYW5zd2VyIiwic2VuZEFuc3dlciIsImNvbm5lY3Rpb25TdGF0ZSIsImljZUNvbm5lY3Rpb25TdGF0ZSIsImljZUdhdGhlcmluZ1N0YXRlIiwiX21heWJlUmVhZHkiLCJnZXRTdGF0cyIsImZsYXR0ZW5WYWx1ZXMiLCJyZXBvcnQiLCJwcm90b3R5cGUiLCJjYWxsIiwidmFsdWVzIiwidmFsdWUiLCJsZW5ndGgiLCJyZXMiLCJyZXBvcnRzIiwicmVzdWx0IiwibmFtZXMiLCJzdGF0IiwiaWQiLCJ0aW1lc3RhbXAiLCJfY29ubmVjdGluZyIsImZpbmRDYW5kaWRhdGVQYWlyIiwiaXRlbXMiLCJyZW1vdGVDYW5kaWRhdGVzIiwibG9jYWxDYW5kaWRhdGVzIiwiY2FuZGlkYXRlUGFpcnMiLCJmb3VuZFNlbGVjdGVkQ2FuZGlkYXRlUGFpciIsIml0ZW0iLCJzZXRTZWxlY3RlZENhbmRpZGF0ZVBhaXIiLCJzZWxlY3RlZENhbmRpZGF0ZVBhaXIiLCJsb2NhbCIsImxvY2FsQ2FuZGlkYXRlSWQiLCJpcCIsIk51bWJlciIsImlwQWRkcmVzcyIsInBvcnROdW1iZXIiLCJnb29nTG9jYWxBZGRyZXNzIiwic3BsaXQiLCJpbmNsdWRlcyIsInJlbW90ZSIsInJlbW90ZUNhbmRpZGF0ZUlkIiwiZ29vZ1JlbW90ZUFkZHJlc3MiLCJzZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCIsImdvb2dBY3RpdmVDb25uZWN0aW9uIiwic2VsZWN0ZWQiLCJrZXlzIiwiX29uSW50ZXJ2YWwiLCJ1bnJlZiIsInNpZ25hbGluZ1N0YXRlIiwic2RwTUxpbmVJbmRleCIsInNkcE1pZCIsIkFycmF5QnVmZmVyIiwiZnJvbSIsImV2ZW50U3RyZWFtIiwic29tZSIsInJlbW90ZVN0cmVhbSIsImFyZ3MiLCJhcmd1bWVudHMiLCJhcHBseSIsIldFQlJUQ19TVVBQT1JUIiwiaWNlU2VydmVycyIsInVybHMiLCJzZHBTZW1hbnRpY3MiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/simple-peer/index.js\n");

/***/ })

};
;